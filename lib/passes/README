--------
Overview
--------

There are several passes that are run over the LLVM IR in order to adjust the
linkage of some variables, and to generate stack transformation metadata.

name_literals/associate-literal pass:

This pass gives a symbol name to anonymous literal strings so that the
alignment tool is able to prevent address spaces clashes across architectures.
Normally, anonymous string literals (e.g., printf("I'm a string literal!")) are
dumped into the .rodata section at the linker's discretion leading to
mis-alignment and garbage pointers across architectures (e.g., a pointer to a
string literal on aarch64 may point to the middle of another string literal on
x86-64).  This pass gives them names so that the alignment tool can put strings
in separate areas of virtual memory to avoid clashes.

staticvar_sections/section-static pass:

This pass adjusts the linkage of static global variables to put them in their
own section so that the alignment tool is able to see and properly align them
(by default, LLVM lumps static global variables in with their respective .data,
.rodata, .bss, etc. and the alignment tool can't align them).

live_values/live-values pass:

This pass runs a live-value analysis over the LLVM IR.  This is used by the
stack-info pass (see below) to gather all live values at function call sites,
or sites where the stack frame can be transformed.

stack_info/stack-info pass:

This pass uses results from the live-value analysis to dump the
"llvm.experimental.stackmap" [1] intrinsic into the IR.  This intrinsic tells
LLVM backends to generate stackmaps at the intrinsic's location.  A stackmap
encodes frame information (e.g., size and address within the function) and live
value location information (e.g., a stack slot or a register) for values
post-register allocation.

[1] Stack maps and patch points in LLVM, http://llvm.org/docs/StackMaps.html

