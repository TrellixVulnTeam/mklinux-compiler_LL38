--- /usr/local/popcorn/src/llvm-3.8_clean/include/llvm/CodeGen/AsmPrinter.h	2016-05-25 11:33:02.184960318 -0400
+++ /usr/local/popcorn/src/llvm-3.8/include/llvm/CodeGen/AsmPrinter.h	2016-06-30 14:31:02.615205799 -0400
@@ -202,9 +202,10 @@
 
   /// Emit the specified function out to the OutStreamer.
   bool runOnMachineFunction(MachineFunction &MF) override {
+    bool modified = TagCallSites(MF);
     SetupMachineFunction(MF);
     EmitFunctionBody();
-    return false;
+    return modified;
   }
 
   //===------------------------------------------------------------------===//
@@ -403,6 +404,14 @@
     EmitLabelPlusOffset(Label, 0, Size, IsSectionRelative);
   }
 
+  /// Find the stackmap intrinsic associated with a function call
+  MachineInstr *FindStackMap(MachineBasicBlock &MBB,
+                             MachineInstr *MI) const;
+
+  /// Move stackmap intrinsics directly after calls to correctly capture
+  /// return addresses
+  bool TagCallSites(MachineFunction &MF);
+
   //===------------------------------------------------------------------===//
   // Dwarf Emission Helper Routines
   //===------------------------------------------------------------------===//
--- /usr/local/popcorn/src/llvm-3.8_clean/include/llvm/CodeGen/MachineFunction.h	2016-05-25 11:33:01.792960322 -0400
+++ /usr/local/popcorn/src/llvm-3.8/include/llvm/CodeGen/MachineFunction.h	2016-07-29 13:05:11.281676624 -0400
@@ -86,6 +86,20 @@
 };
 
 class MachineFunction {
+public:
+  // Typedefs for mappings between IR values and virtual registers
+  typedef DenseMap<const Value*, unsigned> ValVregMap;
+  typedef std::pair<const Value*, unsigned> ValVregPair;
+  typedef DenseMap<const Instruction*, ValVregMap*> InstOpVregMap;
+  typedef std::pair<const Instruction*, ValVregMap*> InstOpVregPair;
+
+  // Typedefs for mappings between IR values and stack slots
+  typedef DenseMap<const Value*, int> ValStackSlotMap;
+  typedef std::pair<const Value*, int> ValStackSlotPair;
+  typedef DenseMap<const Instruction*, ValStackSlotMap*> InstOpStackSlotMap;
+  typedef std::pair<const Instruction*, ValStackSlotMap*> InstOpStackSlotPair;
+
+private:
   const Function *Fn;
   const TargetMachine &Target;
   const TargetSubtargetInfo *STI;
@@ -154,6 +168,12 @@
   // Allocation management for pseudo source values.
   std::unique_ptr<PseudoSourceValueManager> PSVManager;
 
+  /// Map from stackmap operands to virtual registers
+  InstOpVregMap SMOp2Vreg;
+
+  /// Map from stackmap operands to spilled stack slots
+  InstOpStackSlotMap SMOp2StackSlot;
+
   MachineFunction(const MachineFunction &) = delete;
   void operator=(const MachineFunction&) = delete;
 public:
@@ -519,6 +539,39 @@
   /// getPICBaseSymbol - Return a function-local symbol to represent the PIC
   /// base.
   MCSymbol *getPICBaseSymbol() const;
+
+  //===--------------------------------------------------------------------===//
+  // StackMap IR/physical location mappings
+  //
+
+  /// Does a stackmap have any vreg mappings?
+  bool hasVregMapping(const CallInst *SM);
+
+  /// Add an IR/virtual register mapping for a stackmap operand
+  void addSMOpVregMapping(const CallInst *SM, const Value *Val, unsigned Vreg);
+  void addSMOpVregMapping(const CallInst *SM, unsigned Op, unsigned Vreg);
+
+  /// Update vreg references after register coalescing
+  void updateSMVregRefs(SmallDenseMap<unsigned, unsigned, 16> &Changes);
+
+  /// Iterators for the stackmap operand -> vreg map
+  ValVregMap::const_iterator SMOpVreg_begin(const CallInst *SM) const;
+  ValVregMap::const_iterator SMOpVreg_end(const CallInst *SM) const;
+
+  /// Return the virtual register mapped to a stackmap operand
+  unsigned getSMVreg(const CallInst *SM, const Value *Val) const;
+  unsigned getSMVreg(const CallInst *SM, unsigned Op) const;
+
+  /// Add an IR/stack slot mapping for a stackmap operand
+  void addSMOpStackSlotMapping(const CallInst *SM, const Value *Val, int SS);
+  void addSMOpStackSlotMapping(const CallInst *SM, unsigned Op, int SS);
+
+  /// Update stack slot references to new indexes after stack slot coloring
+  void updateSMStackSlotRefs(SmallDenseMap<int, int, 16> &Changes);
+
+  /// Return the stack slot mapped to a stackmap operand
+  int getSMStackSlot(const CallInst *SM, const Value *Val) const;
+  int getSMStackSlot(const CallInst *SM, unsigned Op) const;
 };
 
 //===--------------------------------------------------------------------===//
--- /usr/local/popcorn/src/llvm-3.8_clean/include/llvm/CodeGen/StackMaps.h	2016-05-25 11:33:02.176960318 -0400
+++ /usr/local/popcorn/src/llvm-3.8/include/llvm/CodeGen/StackMaps.h	2016-06-09 11:36:13.644820497 -0400
@@ -143,9 +143,15 @@
     unsigned Size;
     unsigned Reg;
     int64_t Offset;
-    Location() : Type(Unprocessed), Size(0), Reg(0), Offset(0) {}
-    Location(LocationType Type, unsigned Size, unsigned Reg, int64_t Offset)
-        : Type(Type), Size(Size), Reg(Reg), Offset(Offset) {}
+    bool Ptr;
+    bool Alloca;
+    unsigned PtrDataSize;
+    Location() : Type(Unprocessed), Size(0), Reg(0), Offset(0),
+                 Ptr(false), Alloca(false), PtrDataSize(0) {}
+    Location(LocationType Type, unsigned Size, unsigned Reg, int64_t Offset,
+             bool Ptr = false, bool Alloca = false, unsigned PtrDataSize = 0)
+        : Type(Type), Size(Size), Reg(Reg), Offset(Offset),
+          Ptr(Ptr), Alloca(Alloca), PtrDataSize(PtrDataSize) {}
   };
 
   struct LiveOutReg {
@@ -196,15 +202,17 @@
   typedef MapVector<const MCSymbol *, uint64_t> FnStackSizeMap;
 
   struct CallsiteInfo {
+    const MCSymbol *Func;
     const MCExpr *CSOffsetExpr;
     uint64_t ID;
     LocationVec Locations;
     LiveOutVec LiveOuts;
-    CallsiteInfo() : CSOffsetExpr(nullptr), ID(0) {}
-    CallsiteInfo(const MCExpr *CSOffsetExpr, uint64_t ID,
-                 LocationVec &&Locations, LiveOutVec &&LiveOuts)
-        : CSOffsetExpr(CSOffsetExpr), ID(ID), Locations(std::move(Locations)),
-          LiveOuts(std::move(LiveOuts)) {}
+    CallsiteInfo() : Func(nullptr), CSOffsetExpr(nullptr), ID(0) {}
+    CallsiteInfo(const MCSymbol *Func, const MCExpr *CSOffsetExpr,
+                 uint64_t ID, LocationVec &&Locations,
+                 LiveOutVec &&LiveOuts)
+        : Func(Func), CSOffsetExpr(CSOffsetExpr), ID(ID),
+          Locations(std::move(Locations)), LiveOuts(std::move(LiveOuts)) {}
   };
 
   typedef std::vector<CallsiteInfo> CallsiteInfoList;
@@ -214,10 +222,14 @@
   ConstantPool ConstPool;
   FnStackSizeMap FnStackSize;
 
+  /// Get pointer information for stackmap operand
+  void getPointerInfo(User::const_op_iterator &Op, const DataLayout &DL,
+                      bool &isPtr, bool &isAlloca, unsigned &PtrDataSize) const;
+
   MachineInstr::const_mop_iterator
   parseOperand(MachineInstr::const_mop_iterator MOI,
                MachineInstr::const_mop_iterator MOE, LocationVec &Locs,
-               LiveOutVec &LiveOuts) const;
+               LiveOutVec &LiveOuts, User::const_op_iterator &Op) const;
 
   /// \brief Create a live-out register record for the given register @p Reg.
   LiveOutReg createLiveOutReg(unsigned Reg,
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/CodeGen/AsmPrinter/AsmPrinter.cpp	2016-05-25 11:33:09.072960256 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/CodeGen/AsmPrinter/AsmPrinter.cpp	2016-07-08 18:01:24.484832595 -0400
@@ -1292,6 +1292,39 @@
   return CurExceptionSym;
 }
 
+MachineInstr *AsmPrinter::FindStackMap(MachineBasicBlock &MBB,
+                                       MachineInstr *MI) const {
+  MachineBasicBlock::instr_iterator i, ie;
+  for(i = ++MI->getIterator(), ie = MBB.instr_end(); i != ie; i++) {
+    if(i->getOpcode() == TargetOpcode::STACKMAP)
+      return &*i;
+    else if(i->isCall())
+      break;
+  }
+
+  // Call site without a stackmap implies that either the call was generated by
+  // the backend or the LLVM bitcode was never instrumented by the StackInfo
+  // pass.  This is not necessarily an error!
+  return nullptr;
+}
+
+bool AsmPrinter::TagCallSites(MachineFunction &MF) {
+  bool tagged = false;
+  for(auto MBB = MF.begin(), MBBE = MF.end(); MBB != MBBE; MBB++) {
+    for(auto MI = MBB->instr_begin(), MIE = MBB->instr_end(); MI != MIE; MI++) {
+      if(MI->isCall() && !MI->isPseudo()) {
+        MachineInstr *SMI = FindStackMap(*MBB, &*MI);
+        if(SMI != nullptr) {
+          MBB->remove(SMI);
+          MI = MBB->insert(++MI, SMI);
+          tagged = true;
+        }
+      }
+    }
+  }
+  return tagged;
+}
+
 void AsmPrinter::SetupMachineFunction(MachineFunction &MF) {
   this->MF = &MF;
   // Get the function symbol.
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/CodeGen/MachineFunction.cpp	2016-05-25 11:33:10.048960247 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/CodeGen/MachineFunction.cpp	2016-07-29 13:52:16.149651045 -0400
@@ -145,6 +145,11 @@
     WinEHInfo->~WinEHFuncInfo();
     Allocator.Deallocate(WinEHInfo);
   }
+
+  for(auto i = SMOp2Vreg.begin(), e = SMOp2Vreg.end(); i != e; i++)
+    delete i->second;
+  for(auto i = SMOp2StackSlot.begin(), e = SMOp2StackSlot.end(); i != e; i++)
+    delete i->second;
 }
 
 const DataLayout &MachineFunction::getDataLayout() const {
@@ -517,6 +522,180 @@
                                Twine(getFunctionNumber()) + "$pb");
 }
 
+/// Does a stackmap have any vreg mappings?
+bool MachineFunction::hasVregMapping(const CallInst *SM)
+{
+  return SMOp2Vreg.find(SM) != SMOp2Vreg.end();
+}
+
+/// Add an IR/virtual register mapping for a stackmap operand
+void MachineFunction::addSMOpVregMapping(const CallInst *SM,
+                                         const Value *Val,
+                                         unsigned Vreg) {
+  InstOpVregMap::iterator it;
+  std::pair<InstOpVregMap::iterator, bool> ins;
+
+  assert(SM && "Invalid stackmap");
+  assert(Val && "Invalid operand");
+
+  if((it = SMOp2Vreg.find(SM)) == SMOp2Vreg.end())
+  {
+    ins = SMOp2Vreg.insert(InstOpVregPair(SM, new ValVregMap()));
+    assert(ins.second && "Map insertion error");
+    it = ins.first;
+  }
+  it->second->insert(ValVregPair(Val, Vreg));
+}
+
+void MachineFunction::addSMOpVregMapping(const CallInst *SM,
+                                         unsigned Op,
+                                         unsigned Vreg) {
+  assert(SM && "Invalid stackmap");
+  assert(Op < SM->getNumArgOperands() && "Invalid operand number");
+  addSMOpVregMapping(SM, SM->getArgOperand(Op), Vreg);
+}
+
+/// Update vreg references after register coalescing
+void
+MachineFunction::updateSMVregRefs(SmallDenseMap<unsigned, unsigned, 16> &Changes)
+{
+  InstOpVregMap::iterator i, ie;
+  if(Changes.size()) {
+    // Iterate over all stackmaps
+    DEBUG(dbgs() << "Updating stackmap operand vreg references\n";);
+    for(i = SMOp2Vreg.begin(), ie = SMOp2Vreg.end(); i != ie; i++) {
+      // Iterate over all operand/vreg mappings
+      ValVregMap *Map = i->second;
+      ValVregMap::iterator j, je;
+      for(j = Map->begin(), je = Map->end(); j != je; j++) {
+        // There may be multiple coalescings, so loop until all changes have
+        // been applied
+        SmallDenseMap<unsigned, unsigned, 16>::iterator it;
+        while((it = Changes.find(j->second)) != Changes.end()) {
+          DEBUG(
+            j->first->printAsOperand(dbgs());
+            dbgs() << ": from " << TargetRegisterInfo::virtReg2Index(j->second)
+                   << " to " << TargetRegisterInfo::virtReg2Index(it->second)
+                   << "\n";
+          );
+          j->second = it->second;
+        }
+      }
+    }
+  }
+}
+
+/// Iterators for the stackmap operand -> vreg map
+MachineFunction::ValVregMap::const_iterator
+MachineFunction::SMOpVreg_begin(const CallInst *SM) const {
+  assert(SM && "Invalid stackmap");
+  InstOpVregMap::const_iterator it = SMOp2Vreg.find(SM);
+  assert(it != SMOp2Vreg.end() && "Stackmap not present in location mappings");
+  return it->second->begin();
+}
+
+MachineFunction::ValVregMap::const_iterator
+MachineFunction::SMOpVreg_end(const CallInst *SM) const {
+  assert(SM && "Invalid stackmap");
+  InstOpVregMap::const_iterator it = SMOp2Vreg.find(SM);
+  assert(it != SMOp2Vreg.end() && "Stackmap not present in location mappings");
+  return it->second->end();
+}
+
+/// Return the virtual register mapped to a stackmap operand
+unsigned MachineFunction::getSMVreg(const CallInst *SM,
+                                    const Value *Val) const {
+  assert(SM && "Invalid stackmap");
+  assert(Val && "Invalid operand");
+
+  InstOpVregMap::const_iterator i = SMOp2Vreg.find(SM);
+  if(i != SMOp2Vreg.end())
+  {
+    ValVregMap::const_iterator j = i->second->find(Val);
+    if(j != i->second->end()) return j->second;
+  }
+  return UINT_MAX;
+}
+
+unsigned MachineFunction::getSMVreg(const CallInst *SM, unsigned Op) const {
+  assert(SM && "Invalid stackmap");
+  assert(Op < SM->getNumArgOperands() && "Invalid operand number");
+  return getSMVreg(SM, SM->getArgOperand(Op));
+}
+
+/// Add an IR/stack slot mapping for a stackmap operand
+void MachineFunction::addSMOpStackSlotMapping(const CallInst *SM,
+                                              const Value *Val,
+                                              int SS) {
+  InstOpStackSlotMap::iterator it;
+  std::pair<InstOpStackSlotMap::iterator, bool> ins;
+
+  assert(SM && "Invalid stackmap");
+  assert(Val && "Invalid operand");
+
+  if((it = SMOp2StackSlot.find(SM)) == SMOp2StackSlot.end())
+  {
+    ins = SMOp2StackSlot.insert(InstOpStackSlotPair(SM, new ValStackSlotMap()));
+    assert(ins.second && "Map insertion error");
+    it = ins.first;
+  }
+  it->second->insert(ValStackSlotPair(Val, SS));
+}
+
+void MachineFunction::addSMOpStackSlotMapping(const CallInst *SM,
+                                              unsigned Op,
+                                              int SS) {
+  assert(SM && "Invalid stackmap");
+  assert(Op < SM->getNumArgOperands() && "Invalid operand number");
+  addSMOpStackSlotMapping(SM, SM->getArgOperand(Op), SS);
+}
+
+/// Update stack slot references to new indexes after stack slot coloring
+void
+MachineFunction::updateSMStackSlotRefs(SmallDenseMap<int, int, 16> &Changes) {
+  InstOpStackSlotMap::iterator i, ie;
+  if(Changes.size()) {
+    // Iterate over all stackmaps
+    DEBUG(dbgs() << "Updating stackmap operand stack slot references\n";);
+    for(i = SMOp2StackSlot.begin(), ie = SMOp2StackSlot.end(); i != ie; i++) {
+      // Iterate over all operand/stack slot mappings
+      ValStackSlotMap *Map = i->second;
+      ValStackSlotMap::iterator j, je;
+      for(j = Map->begin(), je = Map->end(); j != je; j++) {
+        SmallDenseMap<int, int, 16>::iterator it;
+        if((it = Changes.find(j->second)) != Changes.end()) {
+          DEBUG(
+            j->first->printAsOperand(dbgs());
+            dbgs() << ": from " << j->second << " to " << it->second << "\n";
+          );
+          j->second = it->second;
+        }
+      }
+    }
+  }
+}
+
+/// Return the stack slot mapped to a stackmap operand
+int MachineFunction::getSMStackSlot(const CallInst *SM,
+                                    const Value *Val) const {
+  assert(SM && "Invalid stackmap");
+  assert(Val && "Invalid operand");
+
+  InstOpStackSlotMap::const_iterator i = SMOp2StackSlot.find(SM);
+  if(i != SMOp2StackSlot.end())
+  {
+    ValStackSlotMap::const_iterator j = i->second->find(Val);
+    if(j != i->second->end()) return j->second;
+  }
+  return INT_MAX;
+}
+
+int MachineFunction::getSMStackSlot(const CallInst *SM, unsigned Op) const {
+  assert(SM && "Invalid stackmap");
+  assert(Op < SM->getNumArgOperands() && "Invalid operand number");
+  return getSMStackSlot(SM, SM->getArgOperand(Op));
+}
+
 //===----------------------------------------------------------------------===//
 //  MachineFrameInfo implementation
 //===----------------------------------------------------------------------===//
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/CodeGen/RegAllocBase.cpp	2016-05-25 11:33:10.044960247 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/CodeGen/RegAllocBase.cpp	2016-07-29 13:45:01.721654978 -0400
@@ -14,12 +14,14 @@
 
 #include "RegAllocBase.h"
 #include "Spiller.h"
+#include "llvm/IR/IntrinsicInst.h"
 #include "llvm/ADT/Statistic.h"
 #include "llvm/CodeGen/LiveIntervalAnalysis.h"
 #include "llvm/CodeGen/LiveRangeEdit.h"
 #include "llvm/CodeGen/LiveRegMatrix.h"
 #include "llvm/CodeGen/MachineInstr.h"
 #include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
 #include "llvm/CodeGen/VirtRegMap.h"
 #include "llvm/Target/TargetRegisterInfo.h"
 #ifndef NDEBUG
@@ -152,4 +154,150 @@
       ++NumNewQueued;
     }
   }
+
+  if(VRM->getMachineFunction().getFrameInfo()->hasStackMap())
+    findSpilledStackmapOperands();
+}
+
+void RegAllocBase::findSpilledStackmapOperands()
+{
+  // Gather stackmap machine instructions, the IR instructions which generated
+  // the stackmaps, and their associated call machine instructions
+  typedef std::tuple<const CallInst *,
+                     const MachineInstr *,
+                     const MachineInstr *> SMInstr;
+  SmallVector<SMInstr, 32> SM;
+  MachineFunction &MF = VRM->getMachineFunction();
+  for(auto MBB = MF.begin(), MBBE = MF.end(); MBB != MBBE; MBB++) {
+    for(auto MI = MBB->instr_begin(), MIE = MBB->instr_end();
+        MI != MIE;
+        MI++) {
+      if(MI->getOpcode() == TargetOpcode::STACKMAP) {
+        assert(MI->getOperand(0).isImm() && "Invalid stackmap ID");
+        int64_t ID = MI->getOperand(0).getImm();
+        if(ID == 0) continue;
+
+        // Find the stackmap IR instruction
+        const std::string SMName("llvm.experimental.stackmap");
+        const BasicBlock *BB = MI->getParent()->getBasicBlock();
+        const CallInst *SMIR = nullptr;
+        for(auto I = BB->begin(), IE = BB->end(); I != IE; I++)
+        {
+          const IntrinsicInst *II;
+          if((II = dyn_cast<IntrinsicInst>(&*I)) &&
+             II->getCalledFunction()->getName() == SMName &&
+             cast<ConstantInt>(II->getArgOperand(0))->getSExtValue() == ID) {
+            SMIR = cast<CallInst>(II);
+            break;
+          }
+        }
+        assert(SMIR && "Could not find stackmap IR instruction");
+        if(!MF.hasVregMapping(SMIR)) continue;
+
+        // Find the call instruction
+        const MachineInstr *MCI = MI->getPrevNode();
+        while(MCI != nullptr) {
+          if(MCI->isCall()) break;
+          MCI = MCI->getPrevNode();
+        }
+        if(!MCI) {
+          DEBUG(
+            dbgs() << "WARNING: ";
+            SMIR->printAsOperand(dbgs());
+            dbgs() << ": could not find associated call instruction "
+                      "(has it been lowered to a native instruction?)\n";
+          );
+          continue;
+        }
+
+        SM.push_back(SMInstr(SMIR, &*MI, MCI));
+      }
+    }
+  }
+
+  // Iterate over all stackmaps to add mappings between stackmap operands in
+  // virtual registers and spilled stack slots around call sites.
+  std::set<MachineFunction::ValVregPair> split;
+  const MachineFrameInfo *MFI = MF.getFrameInfo();
+  for(auto S = SM.begin(), SE = SM.end(); S != SE; S++) {
+    // Iterate over stackmap operand vregs to see which do not exist in the
+    // VirtRegMap (indicating they have been split into child vregs).  If
+    // they've been split, then they've been spilled around the call site.
+    for(auto i = MF.SMOpVreg_begin(std::get<0>(*S)),
+        e = MF.SMOpVreg_end(std::get<0>(*S));
+        i != e; i++) {
+      const Value *Val = i->first;
+      unsigned Reg = i->second;
+      assert(TargetRegisterInfo::isVirtualRegister(Reg) &&
+             "non-virtual register");
+
+      if(!VRM->hasPhys(Reg)) {
+        int SS = VRM->getStackSlot(Reg);
+        if(SS != VirtRegMap::NO_STACK_SLOT &&
+           MFI->getObjectIndexBegin() <= SS && SS < MFI->getObjectIndexEnd() &&
+           !MFI->isDeadObjectIndex(SS))
+          MF.addSMOpStackSlotMapping(std::get<0>(*S), Val, SS);
+        else {
+          DEBUG(
+            Val->printAsOperand(dbgs());
+            dbgs() << ": " << TargetRegisterInfo::virtReg2Index(Reg)
+                   << " (" << Reg << ") is spilled\n";
+          );
+          split.insert(*i);
+        }
+      }
+    }
+
+    // Walk through instructions from call to stackmap, watching for spill
+    // slot references.
+    const MachineInstr *Cur = std::get<2>(*S)->getNextNode(),
+                       *End = std::get<1>(*S);
+    while(Cur != End && split.size()) {
+      if(Cur->mayLoad()) {
+        // Find the defined vreg & stack slot being loaded
+        unsigned Vreg = 0;
+        int SS = VirtRegMap::NO_STACK_SLOT;
+        for(unsigned i = 0, e = Cur->getNumOperands(); i != e; i++) {
+          const MachineOperand &MO = Cur->getOperand(i);
+          if(MO.isFI()) SS = MO.getIndex();
+          else if(MO.isReg() && MO.isDef()) Vreg = MO.getReg();
+        }
+
+        // Search for stackmap operand vregs who are ancestors of defined vreg
+        if(Vreg != 0 && SS != VirtRegMap::NO_STACK_SLOT) {
+          for(auto splitIt = split.begin(), splitEnd = split.end();
+              splitIt != splitEnd;
+              splitIt++) {
+            if(splitIt->second == VRM->getOriginal(Vreg)) {
+              DEBUG(
+                splitIt->first->printAsOperand(dbgs());
+                dbgs() << ": spilled to stack slot " << SS << "\n";
+              );
+              MF.addSMOpStackSlotMapping(std::get<0>(*S), splitIt->first, SS);
+              split.erase(*splitIt);
+              // TODO break? Are there ever other spilled vregs (i.e., elements
+              // of split) that are resolved by this machine instruction?
+            }
+          }
+        }
+        else {
+          DEBUG(
+            dbgs() << "WARNING: ignoring machine instruction:\n";
+            Cur->dump();
+          );
+        }
+      }
+      Cur = Cur->getNextNode();
+    }
+
+    if(split.size()) {
+      DEBUG(
+        dbgs() << "WARNING: could not resolve all split registers:";
+        for(auto it = split.begin(), end = split.end(); it != end; it++)
+          dbgs() << " " << TargetRegisterInfo::virtReg2Index(it->second);
+        dbgs() << "\n";
+      );
+    }
+    split.clear();
+  }
 }
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/CodeGen/RegAllocBase.h	2016-05-25 11:33:10.040960247 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/CodeGen/RegAllocBase.h	2016-07-27 09:37:26.459354223 -0400
@@ -105,6 +105,8 @@
 
 private:
   void seedLiveRegs();
+
+  void findSpilledStackmapOperands();
 };
 
 } // end namespace llvm
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/CodeGen/RegisterCoalescer.cpp	2016-05-25 11:33:09.536960252 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/CodeGen/RegisterCoalescer.cpp	2016-07-29 13:47:25.377653678 -0400
@@ -89,6 +89,7 @@
     const MachineLoopInfo* Loops;
     AliasAnalysis *AA;
     RegisterClassInfo RegClassInfo;
+    SmallDenseMap<unsigned, unsigned, 16> Changes;
 
     /// A LaneMask to remember on which subregister live ranges we need to call
     /// shrinkToUses() later.
@@ -234,6 +235,13 @@
       }
     }
 
+    /// Record coalesced registers so we can update the stackmap operand/vreg
+    /// mappings post-register coalescing
+    void recordCoalescing(unsigned Vreg, unsigned NewVreg) {
+      assert(Changes.find(Vreg) == Changes.end() && "Unhandled coalescing");
+      Changes.insert(std::pair<unsigned, unsigned>(Vreg, NewVreg));
+    }
+
   public:
     static char ID; ///< Class identification, replacement for typeinfo
     RegisterCoalescer() : MachineFunctionPass(ID) {
@@ -1453,6 +1461,9 @@
   // Update regalloc hint.
   TRI->updateRegAllocHint(CP.getSrcReg(), CP.getDstReg(), *MF);
 
+  // Record coalescing
+  recordCoalescing(CP.getSrcReg(), CP.getDstReg());
+
   DEBUG({
     dbgs() << "\tSuccess: " << PrintReg(CP.getSrcReg(), TRI, CP.getSrcIdx())
            << " -> " << PrintReg(CP.getDstReg(), TRI, CP.getDstIdx()) << '\n';
@@ -2974,6 +2985,10 @@
     }
   }
 
+  // Update stackmap operand/vreg mappings to reflect results of coalescing
+  fn.updateSMVregRefs(Changes);
+  Changes.clear();
+
   DEBUG(dump());
   if (VerifyCoalescing)
     MF->verify(this, "After register coalescing");
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/CodeGen/SelectionDAG/FastISel.cpp	2016-05-25 11:33:09.544960252 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/CodeGen/SelectionDAG/FastISel.cpp	2016-07-29 13:51:06.233651678 -0400
@@ -594,8 +594,29 @@
       if (!Reg)
         return false;
       Ops.push_back(MachineOperand::CreateReg(Reg, /*IsDef=*/false));
+
+      // Add mappings for stackmap operands that are in virtual registers, as
+      // these can be allocated to caller-saved registers (in which case we
+      // need to find the spill slots around call sites).
+      if(TargetRegisterInfo::isVirtualRegister(Reg)) {
+        DEBUG(
+          Val->printAsOperand(dbgs());
+          dbgs() << ": vreg "
+                 << TargetRegisterInfo::virtReg2Index(Reg)
+                 << "\n";
+        );
+        MF->addSMOpVregMapping(CI, i, Reg);
+      }
+      else {
+        DEBUG(
+          dbgs() << "WARNING: skipping operand ";
+          Val->printAsOperand(dbgs());
+          dbgs() << ", which is not in a virtual register\n";
+        );
+      }
     }
   }
+
   return true;
 }
 
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2016-05-25 11:33:09.548960252 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2016-07-29 13:51:12.417651622 -0400
@@ -6782,8 +6782,44 @@
       const TargetLowering &TLI = Builder.DAG.getTargetLoweringInfo();
       Ops.push_back(Builder.DAG.getTargetFrameIndex(
           FI->getIndex(), TLI.getPointerTy(Builder.DAG.getDataLayout())));
-    } else
+    } else {
       Ops.push_back(OpVal);
+
+      // Add mappings for stackmap operands that are in virtual registers, as
+      // these can be allocated to caller-saved registers (in which case we
+      // need to find the spill slots around call sites).
+      // TODO how do we handle non-CopyFromReg types?
+      const CallInst *CI = cast<CallInst>(CS.getInstruction());
+      RegisterSDNode *Reg = nullptr;
+      switch(OpVal.getOpcode()) {
+      case ISD::CopyFromReg:
+        for(unsigned j = 0, je = OpVal.getNumOperands(); j < je; j++)
+          if((Reg = dyn_cast<RegisterSDNode>(OpVal.getOperand(j))) &&
+             TargetRegisterInfo::isVirtualRegister(Reg->getReg()))
+            break;
+        break;
+      default:
+        DEBUG(dbgs() << "WARNING: unhandled operation type "
+                     << OpVal.getNode()->getOperationName() << "\n";);
+        break;
+      }
+      if(Reg) {
+        DEBUG(
+          CS.getArgument(i)->printAsOperand(dbgs());
+          dbgs() << ": vreg "
+                 << TargetRegisterInfo::virtReg2Index(Reg->getReg())
+                 << "\n";
+        );
+        Builder.FuncInfo.MF->addSMOpVregMapping(CI, i, Reg->getReg());
+      }
+      else {
+        DEBUG(
+          dbgs() << "WARNING: skipping operand ";
+          CS.getArgument(i)->printAsOperand(dbgs());
+          dbgs() << ", which is not in a virtual register\n";
+        );
+      }
+    }
   }
 }
 
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/CodeGen/StackMaps.cpp	2016-05-25 11:33:09.148960255 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/CodeGen/StackMaps.cpp	2016-07-29 13:56:02.077648999 -0400
@@ -9,10 +9,12 @@
 
 #include "llvm/CodeGen/StackMaps.h"
 #include "llvm/CodeGen/AsmPrinter.h"
+#include "llvm/CodeGen/MachineModuleInfo.h"
 #include "llvm/CodeGen/MachineFrameInfo.h"
 #include "llvm/CodeGen/MachineFunction.h"
 #include "llvm/CodeGen/MachineInstr.h"
 #include "llvm/IR/DataLayout.h"
+#include "llvm/IR/IntrinsicInst.h"
 #include "llvm/MC/MCContext.h"
 #include "llvm/MC/MCExpr.h"
 #include "llvm/MC/MCObjectFileInfo.h"
@@ -84,44 +86,85 @@
   return (unsigned)RegNum;
 }
 
+void StackMaps::getPointerInfo(User::const_op_iterator &Op,
+                               const DataLayout &DL,
+                               bool &isPtr, bool &isAlloca,
+                               unsigned &PtrDataSize) const {
+  isPtr = false;
+  isAlloca = false;
+  PtrDataSize = 0;
+
+  assert(Op != nullptr && "Invalid stackmap operand");
+  Type *Ty = Op->get()->getType();
+  if(Ty->isPointerTy())
+  {
+    PointerType *PTy = cast<PointerType>(Ty);
+    if(PTy->getElementType()->isSized())
+    {
+      isPtr = true;
+      PtrDataSize = DL.getTypeAllocSize(PTy->getElementType());
+      if(isa<AllocaInst>(Op)) isAlloca = true;
+    }
+  }
+}
+
+/// Return whether or not the specified register is caller-saved
+static bool isCallerSaved(const TargetRegisterInfo *TRI,
+                          MachineInstr::const_mop_iterator MOI)
+{
+  const MachineFunction *MF = MOI->getParent()->getParent()->getParent();
+  unsigned Reg = MOI->getReg();
+  CallingConv::ID CC = MF->getFunction()->getCallingConv();
+  const uint32_t *Mask = TRI->getCallPreservedMask(*MF, CC);
+  return !((Mask[Reg / 32] >> Reg % 32) & 1);
+}
+
 MachineInstr::const_mop_iterator
 StackMaps::parseOperand(MachineInstr::const_mop_iterator MOI,
                         MachineInstr::const_mop_iterator MOE, LocationVec &Locs,
-                        LiveOutVec &LiveOuts) const {
+                        LiveOutVec &LiveOuts, User::const_op_iterator &Op) const {
+  bool isPtr, isAlloca;
+  unsigned PtrDataSize;
+  auto &DL = AP.MF->getDataLayout();
   const TargetRegisterInfo *TRI = AP.MF->getSubtarget().getRegisterInfo();
+
   if (MOI->isImm()) {
+    getPointerInfo(Op, DL, isPtr, isAlloca, PtrDataSize);
     switch (MOI->getImm()) {
     default:
       llvm_unreachable("Unrecognized operand type.");
     case StackMaps::DirectMemRefOp: {
-      auto &DL = AP.MF->getDataLayout();
-
       unsigned Size = DL.getPointerSizeInBits();
       assert((Size % 8) == 0 && "Need pointer size in bytes.");
       Size /= 8;
       unsigned Reg = (++MOI)->getReg();
       int64_t Imm = (++MOI)->getImm();
       Locs.emplace_back(StackMaps::Location::Direct, Size,
-                        getDwarfRegNum(Reg, TRI), Imm);
+                        getDwarfRegNum(Reg, TRI), Imm, isPtr, isAlloca,
+                        PtrDataSize);
       break;
     }
     case StackMaps::IndirectMemRefOp: {
       int64_t Size = (++MOI)->getImm();
+      int64_t AllocSize = DL.getTypeAllocSize(Op->get()->getType());
       assert(Size > 0 && "Need a valid size for indirect memory locations.");
       unsigned Reg = (++MOI)->getReg();
       int64_t Imm = (++MOI)->getImm();
-      Locs.emplace_back(StackMaps::Location::Indirect, Size,
-                        getDwarfRegNum(Reg, TRI), Imm);
+      Locs.emplace_back(StackMaps::Location::Indirect, AllocSize,
+                        getDwarfRegNum(Reg, TRI), Imm, isPtr, isAlloca,
+                        PtrDataSize);
       break;
     }
     case StackMaps::ConstantOp: {
       ++MOI;
       assert(MOI->isImm() && "Expected constant operand.");
       int64_t Imm = MOI->getImm();
-      Locs.emplace_back(Location::Constant, sizeof(int64_t), 0, Imm);
+      Locs.emplace_back(Location::Constant, sizeof(int64_t), 0, Imm,
+                        isPtr, isAlloca, PtrDataSize);
       break;
     }
     }
+    ++Op;
     return ++MOI;
   }
 
@@ -136,17 +179,43 @@
 
     assert(TargetRegisterInfo::isPhysicalRegister(MOI->getReg()) &&
            "Virtreg operands should have been rewritten before now.");
-    const TargetRegisterClass *RC = TRI->getMinimalPhysRegClass(MOI->getReg());
     assert(!MOI->getSubReg() && "Physical subreg still around.");
 
-    unsigned Offset = 0;
-    unsigned DwarfRegNum = getDwarfRegNum(MOI->getReg(), TRI);
-    unsigned LLVMRegNum = TRI->getLLVMRegNum(DwarfRegNum, false);
-    unsigned SubRegIdx = TRI->getSubRegIndex(LLVMRegNum, MOI->getReg());
-    if (SubRegIdx)
-      Offset = TRI->getSubRegIdxOffset(SubRegIdx);
+    size_t valSize = DL.getTypeAllocSize(Op->get()->getType());
+    getPointerInfo(Op, DL, isPtr, isAlloca, PtrDataSize);
+    const MachineFrameInfo *MFI = AP.MF->getFrameInfo();
+    int SS = INT_MAX;
+    if(isCallerSaved(TRI, MOI))
+      SS = AP.MF->getSMStackSlot(cast<CallInst>(Op->getUser()), Op->get());
+
+
+    // If the value is in a caller-saved register, record the spilled location.
+    // Otherwise, record the register number.
+    if(MFI->getObjectIndexBegin() <= SS && SS < MFI->getObjectIndexEnd() &&
+       !MFI->isDeadObjectIndex(SS)) {
+      int64_t Offset = MFI->getObjectOffset(SS) + 16; // RA + old FBP
+      Locs.emplace_back(StackMaps::Location::Indirect, valSize,
+                        getDwarfRegNum(TRI->getFrameRegister(*AP.MF), TRI),
+                        Offset, isPtr, isAlloca, PtrDataSize);
+    } else {
+      if(isCallerSaved(TRI, MOI)) {
+        DEBUG(
+          dbgs() << "WARNING: no spill slot for caller-saved register "
+                 << getDwarfRegNum(MOI->getReg(), TRI) << "\n";
+        );
+      }
+
+      unsigned Offset = 0;
+      unsigned DwarfRegNum = getDwarfRegNum(MOI->getReg(), TRI);
+      unsigned LLVMRegNum = TRI->getLLVMRegNum(DwarfRegNum, false);
+      unsigned SubRegIdx = TRI->getSubRegIndex(LLVMRegNum, MOI->getReg());
+      if (SubRegIdx)
+        Offset = TRI->getSubRegIdxOffset(SubRegIdx);
 
-    Locs.emplace_back(Location::Register, RC->getSize(), DwarfRegNum, Offset);
+      Locs.emplace_back(Location::Register, valSize, DwarfRegNum, Offset,
+                        isPtr, isAlloca, PtrDataSize);
+    }
+    ++Op;
     return ++MOI;
   }
 
@@ -287,6 +356,7 @@
   MCContext &OutContext = AP.OutStreamer->getContext();
   MCSymbol *MILabel = OutContext.createTempSymbol();
   AP.OutStreamer->EmitLabel(MILabel);
+  User::const_op_iterator Op = nullptr;
 
   LocationVec Locations;
   LiveOutVec LiveOuts;
@@ -294,13 +364,33 @@
   if (recordResult) {
     assert(PatchPointOpers(&MI).hasDef() && "Stackmap has no return value.");
     parseOperand(MI.operands_begin(), std::next(MI.operands_begin()), Locations,
-                 LiveOuts);
+                 LiveOuts, Op);
+  }
+
+  // Find the IR stackmap instruction which corresponds to MI so we can emit
+  // type information along with the value's location
+  const BasicBlock *BB = MI.getParent()->getBasicBlock();
+  const IntrinsicInst *IRSM = nullptr;
+  const std::string SMName("llvm.experimental.stackmap");
+  for(auto BBI = BB->begin(), BBE = BB->end(); BBI != BBE; BBI++)
+  {
+    const IntrinsicInst *II;
+    if((II = dyn_cast<IntrinsicInst>(&*BBI)) &&
+       II->getCalledFunction()->getName() == SMName &&
+       cast<ConstantInt>(II->getArgOperand(0))->getZExtValue() == ID)
+    {
+      IRSM = cast<IntrinsicInst>(&*BBI);
+      break;
+    }
   }
+  assert(IRSM && "Could not find associated stackmap instruction");
 
   // Parse operands.
+  Op = std::next(IRSM->arg_begin(), 2);
   while (MOI != MOE) {
-    MOI = parseOperand(MOI, MOE, Locations, LiveOuts);
+    MOI = parseOperand(MOI, MOE, Locations, LiveOuts, Op);
   }
+  assert(Op == IRSM->arg_end() && "did not lower all stackmap operands");
 
   // Move large constants into the constant pool.
   for (auto &Loc : Locations) {
@@ -329,8 +419,8 @@
       MCSymbolRefExpr::create(MILabel, OutContext),
       MCSymbolRefExpr::create(AP.CurrentFnSymForSize, OutContext), OutContext);
 
-  CSInfos.emplace_back(CSOffsetExpr, ID, std::move(Locations),
-                       std::move(LiveOuts));
+  CSInfos.emplace_back(AP.CurrentFnSym, CSOffsetExpr, ID,
+                       std::move(Locations), std::move(LiveOuts));
 
   // Record the stack size of the current function.
   const MachineFrameInfo *MFI = AP.MF->getFrameInfo();
@@ -419,7 +509,7 @@
   DEBUG(dbgs() << WSMP << "functions:\n");
   for (auto const &FR : FnStackSize) {
     DEBUG(dbgs() << WSMP << "function addr: " << FR.first
-                 << " frame size: " << FR.second);
+                 << " frame size: " << FR.second << "\n");
     OS.EmitSymbolValue(FR.first, 8);
     OS.EmitIntValue(FR.second, 8);
   }
@@ -441,6 +531,8 @@
 ///
 /// StkMapRecord[NumRecords] {
 ///   uint64 : PatchPoint ID
+///   uint32 : Index of Function Stack Size Record
+///   uint32 : Padding
 ///   uint32 : Instruction Offset
 ///   uint16 : Reserved (record flags)
 ///   uint16 : NumLocations
@@ -449,6 +541,10 @@
 ///     uint8  : Size in Bytes
 ///     uint16 : Dwarf RegNum
 ///     int32  : Offset
+///     uint8  : Is it a pointer?
+///     uint8  : Is it an alloca?
+///     uint16 : Padding
+///     uint32 : Size of pointed-to data
 ///   }
 ///   uint16 : Padding
 ///   uint16 : NumLiveOuts
@@ -489,6 +585,8 @@
     }
 
     OS.EmitIntValue(CSI.ID, 8);
+    OS.EmitIntValue(FnStackSize.find(CSI.Func) - FnStackSize.begin(), 4);
+    OS.EmitIntValue(0, 4);
     OS.EmitValue(CSI.CSOffsetExpr, 4);
 
     // Reserved for flags.
@@ -500,6 +598,10 @@
       OS.EmitIntValue(Loc.Size, 1);
       OS.EmitIntValue(Loc.Reg, 2);
       OS.EmitIntValue(Loc.Offset, 4);
+      OS.EmitIntValue(Loc.Ptr, 1);
+      OS.EmitIntValue(Loc.Alloca, 1);
+      OS.EmitIntValue(0, 2);
+      OS.EmitIntValue(Loc.PtrDataSize, 4);
     }
 
     // Num live-out registers and padding to align to 4 byte.
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/CodeGen/StackSlotColoring.cpp	2016-05-25 11:33:10.052960247 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/CodeGen/StackSlotColoring.cpp	2016-07-27 14:44:48.227187230 -0400
@@ -278,6 +278,7 @@
   SmallVector<int, 16> SlotMapping(NumObjs, -1);
   SmallVector<float, 16> SlotWeights(NumObjs, 0.0);
   SmallVector<SmallVector<int, 4>, 16> RevMap(NumObjs);
+  SmallDenseMap<int, int, 16> SlotChanges;
   BitVector UsedColors(NumObjs);
 
   DEBUG(dbgs() << "Color spill slot intervals:\n");
@@ -292,7 +293,9 @@
     SlotWeights[NewSS] += li->weight;
     UsedColors.set(NewSS);
     Changed |= (SS != NewSS);
+    if(SS != NewSS) SlotChanges[SS] = NewSS;
   }
+  MF.updateSMStackSlotRefs(SlotChanges);
 
   DEBUG(dbgs() << "\nSpill slots after coloring:\n");
   for (unsigned i = 0, e = SSIntervals.size(); i != e; ++i) {
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/Target/AArch64/AArch64AsmPrinter.cpp	2016-05-25 11:33:05.876960285 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/Target/AArch64/AArch64AsmPrinter.cpp	2016-05-26 17:29:36.100063984 -0400
@@ -129,8 +129,8 @@
     // linker can safely perform dead code stripping.  Since LLVM never
     // generates code that does this, it is always safe to set.
     OutStreamer->EmitAssemblerFlag(MCAF_SubsectionsViaSymbols);
-    SM.serializeToStackMapSection();
   }
+  SM.serializeToStackMapSection();
 }
 
 MachineLocation
--- /usr/local/popcorn/src/llvm-3.8_clean/lib/Target/X86/X86AsmPrinter.cpp	2016-05-25 11:33:05.560960288 -0400
+++ /usr/local/popcorn/src/llvm-3.8/lib/Target/X86/X86AsmPrinter.cpp	2016-06-30 11:42:55.391297140 -0400
@@ -49,6 +49,8 @@
 bool X86AsmPrinter::runOnMachineFunction(MachineFunction &MF) {
   Subtarget = &MF.getSubtarget<X86Subtarget>();
 
+  bool modified = TagCallSites(MF);
+
   SMShadowTracker.startFunction(MF);
 
   SetupMachineFunction(MF);
@@ -66,8 +68,8 @@
   // Emit the rest of the function body.
   EmitFunctionBody();
 
-  // We didn't modify anything.
-  return false;
+  // We may have modified where stack map intrinsics are located.
+  return modified;
 }
 
 /// printSymbolOperand - Print a raw symbol reference operand.  This handles
