--------
Overview
--------

The modifications to the toolchain mainly affect how live value location
information is generated by the architecture-specific backends.  In particular,
we modify where and how the "llvm.experimental.stackmap" intrinsic generates
location information for equivalence points in the application's execution.

The "stack-info" middle-end pass runs a liveness analysis over the IR and
inserts stackmap intrinsics containing all live values at all function call
sites.  This intrinsic notifies the LLVM backends to generate the locations of
these live values and place them in a special ELF section named
".llvm_stackmaps".  These sections are parsed after compilation and alignment
to generate the stack transformation metadata. 

Most of the backend modifications are due to the fact that because stackmaps
are an IR-level intrinsic, they encode the instruction address and live value
information after the function call procedure has finished rather than directly
after the function call returns (but before values have been restored from the
stack), e.g., directly after the called function executes the "ret" instruction
on x86-64.  These modifications compensate for this, as well handling a few
cross-architecture typing issues (e.g., char/register sizes) and generating
extra type metadata (e.g., is the value a pointer? an alloca? etc.).

Note: these modifications only work for register allocators that work off of
the virtual register allocation mechanisms, meaning that the fast register
allocator (which allocates registers/stack slots directly) is not supported.

