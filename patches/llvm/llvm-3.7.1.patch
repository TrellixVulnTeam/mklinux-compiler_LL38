Index: include/llvm/CodeGen/AsmPrinter.h
===================================================================
--- include/llvm/CodeGen/AsmPrinter.h	(revision 277823)
+++ include/llvm/CodeGen/AsmPrinter.h	(working copy)
@@ -199,9 +199,10 @@
 
   /// Emit the specified function out to the OutStreamer.
   bool runOnMachineFunction(MachineFunction &MF) override {
+    bool modified = TagCallSites(MF);
     SetupMachineFunction(MF);
     EmitFunctionBody();
-    return false;
+    return modified;
   }
 
   //===------------------------------------------------------------------===//
@@ -393,6 +394,14 @@
     EmitLabelPlusOffset(Label, 0, Size, IsSectionRelative);
   }
 
+  /// Find the stackmap intrinsic associated with a function call
+  MachineInstr *FindStackMap(MachineBasicBlock &MBB,
+                             MachineInstr *MI) const;
+
+  /// Move stackmap intrinsics directly after calls to correctly capture
+  /// return addresses
+  bool TagCallSites(MachineFunction &MF);
+
   //===------------------------------------------------------------------===//
   // Dwarf Emission Helper Routines
   //===------------------------------------------------------------------===//
Index: include/llvm/CodeGen/MachineFunction.h
===================================================================
--- include/llvm/CodeGen/MachineFunction.h	(revision 277823)
+++ include/llvm/CodeGen/MachineFunction.h	(working copy)
@@ -20,6 +20,7 @@
 
 #include "llvm/ADT/ilist.h"
 #include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/IR/Instructions.h"
 #include "llvm/IR/DebugLoc.h"
 #include "llvm/IR/Metadata.h"
 #include "llvm/Support/Allocator.h"
@@ -84,6 +85,20 @@
 };
 
 class MachineFunction {
+public:
+  // Mappings between IR values and stack slots
+  typedef DenseMap<const Value*, int> ValStackSlotMap;
+  typedef std::pair<const Value*, int> ValStackSlotPair;
+  typedef DenseMap<const Instruction*, ValStackSlotMap> InstOpStackSlotMap;
+  typedef std::pair<const Instruction*, ValStackSlotMap> InstOpStackSlotPair;
+
+  // Mappings between IR values and physical registers
+  typedef DenseMap<const Value*, unsigned> ValPhysRegMap;
+  typedef std::pair<const Value*, unsigned> ValPhysRegPair;
+  typedef DenseMap<const Instruction*, ValPhysRegMap> InstOpPhysRegMap;
+  typedef std::pair<const Instruction*, ValPhysRegMap> InstOpPhysRegPair;
+
+private:
   const Function *Fn;
   const TargetMachine &Target;
   const TargetSubtargetInfo *STI;
@@ -145,6 +160,12 @@
   /// True if the function includes any inline assembly.
   bool HasInlineAsm;
 
+  /// Map from stackmap operands to spilled stack slots
+  InstOpStackSlotMap SMOp2StackSlot;
+
+  /// Map from stackmap operands to physical registers
+  InstOpPhysRegMap SMOp2PhysReg;
+
   MachineFunction(const MachineFunction &) = delete;
   void operator=(const MachineFunction&) = delete;
 public:
@@ -457,6 +478,9 @@
     return Mask;
   }
 
+  /// Is a register caller-saved?
+  bool isCallerSaved(unsigned Reg) const;
+
   /// allocateMemRefsArray - Allocate an array to hold MachineMemOperand
   /// pointers.  This array is owned by the MachineFunction.
   MachineInstr::mmo_iterator allocateMemRefsArray(unsigned long Num);
@@ -488,6 +512,29 @@
   /// getPICBaseSymbol - Return a function-local symbol to represent the PIC
   /// base.
   MCSymbol *getPICBaseSymbol() const;
+
+  //===--------------------------------------------------------------------===//
+  // StackMap IR/physical location mappings
+  //
+
+  /// Add an IR/stack slot mapping for a stackmap operand
+  void addSMOpStackSlotMapping(const CallInst *SM, const Value *Val, int SS);
+  void addSMOpStackSlotMapping(const CallInst *SM, unsigned Op, int SS);
+
+  /// Update stack slot references to new indexes after stack slot coloring
+  void updateSMStackSlotRefs(SmallDenseMap<int, int, 16> &Changes);
+
+  /// Return the stack slot mapped to a stackmap operand
+  int getSMStackSlot(const CallInst *SM, const Value *Val) const;
+  int getSMStackSlot(const CallInst *SM, unsigned Op) const;
+
+  /// Add an IR/physical register mapping for a stackmap operand
+  void addSMOpPhysRegMapping(const CallInst *SM, const Value *Val, unsigned Reg);
+  void addSMOpPhysRegMapping(const CallInst *SM, unsigned Op, unsigned Reg);
+
+  /// Return the physical register mapped to a stackmap operand
+  unsigned getSMPhysReg(const CallInst *SM, const Value *Val) const;
+  unsigned getSMPhysReg(const CallInst *SM, unsigned Op) const;
 };
 
 //===--------------------------------------------------------------------===//
Index: include/llvm/CodeGen/StackMaps.h
===================================================================
--- include/llvm/CodeGen/StackMaps.h	(revision 277823)
+++ include/llvm/CodeGen/StackMaps.h	(working copy)
@@ -142,9 +142,15 @@
     unsigned Size;
     unsigned Reg;
     int64_t Offset;
-    Location() : Type(Unprocessed), Size(0), Reg(0), Offset(0) {}
-    Location(LocationType Type, unsigned Size, unsigned Reg, int64_t Offset)
-        : Type(Type), Size(Size), Reg(Reg), Offset(Offset) {}
+    bool Ptr;
+    bool Alloca;
+    unsigned PtrDataSize;
+    Location() : Type(Unprocessed), Size(0), Reg(0), Offset(0),
+                 Ptr(false), Alloca(false), PtrDataSize(0) {}
+    Location(LocationType Type, unsigned Size, unsigned Reg, int64_t Offset,
+             bool Ptr, bool Alloca, unsigned PtrDataSize)
+        : Type(Type), Size(Size), Reg(Reg), Offset(Offset),
+          Ptr(Ptr), Alloca(Alloca), PtrDataSize(PtrDataSize) {}
   };
 
   struct LiveOutReg {
@@ -195,15 +201,17 @@
   typedef MapVector<const MCSymbol *, uint64_t> FnStackSizeMap;
 
   struct CallsiteInfo {
+    const MCSymbol *Func;
     const MCExpr *CSOffsetExpr;
     uint64_t ID;
     LocationVec Locations;
     LiveOutVec LiveOuts;
-    CallsiteInfo() : CSOffsetExpr(nullptr), ID(0) {}
-    CallsiteInfo(const MCExpr *CSOffsetExpr, uint64_t ID,
-                 LocationVec &&Locations, LiveOutVec &&LiveOuts)
-        : CSOffsetExpr(CSOffsetExpr), ID(ID), Locations(std::move(Locations)),
-          LiveOuts(std::move(LiveOuts)) {}
+    CallsiteInfo() : Func(nullptr), CSOffsetExpr(nullptr), ID(0) {}
+    CallsiteInfo(const MCSymbol *Func, const MCExpr *CSOffsetExpr,
+                 uint64_t ID, LocationVec &&Locations,
+                 LiveOutVec &&LiveOuts)
+        : Func(Func), CSOffsetExpr(CSOffsetExpr), ID(ID),
+          Locations(std::move(Locations)), LiveOuts(std::move(LiveOuts)) {}
   };
 
   typedef std::vector<CallsiteInfo> CallsiteInfoList;
@@ -213,10 +221,14 @@
   ConstantPool ConstPool;
   FnStackSizeMap FnStackSize;
 
+  /// Get pointer information for stackmap operand
+  void getPointerInfo(const Value *Op, const DataLayout &DL, bool &isPtr,
+                      bool &isAlloca, unsigned &PtrDataSize) const;
+
   MachineInstr::const_mop_iterator
   parseOperand(MachineInstr::const_mop_iterator MOI,
                MachineInstr::const_mop_iterator MOE, LocationVec &Locs,
-               LiveOutVec &LiveOuts) const;
+               LiveOutVec &LiveOuts, User::const_op_iterator &Op) const;
 
   /// \brief Create a live-out register record for the given register @p Reg.
   LiveOutReg createLiveOutReg(unsigned Reg,
Index: lib/CodeGen/AsmPrinter/AsmPrinter.cpp
===================================================================
--- lib/CodeGen/AsmPrinter/AsmPrinter.cpp	(revision 277823)
+++ lib/CodeGen/AsmPrinter/AsmPrinter.cpp	(working copy)
@@ -1160,6 +1160,41 @@
   return CurExceptionSym;
 }
 
+MachineInstr *AsmPrinter::FindStackMap(MachineBasicBlock &MBB,
+                                       MachineInstr *MI) const {
+  MachineBasicBlock::instr_iterator i, ie;
+  for(i = MI->getNextNode(), ie = MBB.instr_end();
+      i != ie;
+      i = i->getNextNode()) {
+    if(i->getOpcode() == TargetOpcode::STACKMAP)
+      return &*i;
+    else if(i->isCall())
+      break;
+  }
+
+  // Call site without a stackmap implies that either the call was generated by
+  // the backend or the LLVM bitcode was never instrumented by the StackInfo
+  // pass.  This is not necessarily an error!
+  return nullptr;
+}
+
+bool AsmPrinter::TagCallSites(MachineFunction &MF) {
+  bool tagged = false;
+  for(auto MBB = MF.begin(), MBBE = MF.end(); MBB != MBBE; MBB++) {
+    for(auto MI = MBB->instr_begin(), MIE = MBB->instr_end(); MI != MIE; MI++) {
+      if(MI->isCall() && !MI->isPseudo()) {
+        MachineInstr *SMI = FindStackMap(*MBB, &*MI);
+        if(SMI != nullptr) {
+          MBB->remove(SMI);
+          MI = MBB->insert(++MI, SMI);
+          tagged = true;
+        }
+      }
+    }
+  }
+  return tagged;
+}
+
 void AsmPrinter::SetupMachineFunction(MachineFunction &MF) {
   this->MF = &MF;
   // Get the function symbol.
Index: lib/CodeGen/MachineFunction.cpp
===================================================================
--- lib/CodeGen/MachineFunction.cpp	(revision 277823)
+++ lib/CodeGen/MachineFunction.cpp	(working copy)
@@ -253,6 +253,15 @@
                                MMO->getBaseAlignment());
 }
 
+/// Is a register caller-saved?
+bool MachineFunction::isCallerSaved(unsigned Reg) const {
+  assert(TargetRegisterInfo::isPhysicalRegister(Reg) && "Invalid register");
+  CallingConv::ID CC = Fn->getCallingConv();
+  const uint32_t *Mask =
+    RegInfo->getTargetRegisterInfo()->getCallPreservedMask(*this, CC);
+  return !((Mask[Reg / 32] >> Reg % 32) & 1);
+}
+
 MachineInstr::mmo_iterator
 MachineFunction::allocateMemRefsArray(unsigned long Num) {
   return Allocator.Allocate<MachineMemOperand *>(Num);
@@ -482,6 +491,136 @@
                                Twine(getFunctionNumber()) + "$pb");
 }
 
+/// Add an IR/stack slot mapping for a stackmap operand
+void MachineFunction::addSMOpStackSlotMapping(const CallInst *SM,
+                                              const Value *Val,
+                                              int SS) {
+  InstOpStackSlotMap::iterator it;
+  std::pair<InstOpStackSlotMap::iterator, bool> ins;
+
+  assert(SM && "Invalid stackmap");
+  assert(Val && "Invalid operand");
+  assert(FrameInfo->getObjectIndexBegin() <= SS &&
+         SS < FrameInfo->getObjectIndexEnd() &&
+         !FrameInfo->isDeadObjectIndex(SS) &&
+         "Invalid stack slot");
+
+  if((it = SMOp2StackSlot.find(SM)) == SMOp2StackSlot.end())
+  {
+    ValStackSlotMap NewMap;
+    ins = SMOp2StackSlot.insert(InstOpStackSlotPair(SM, std::move(NewMap)));
+    assert(ins.second && "Map insertion error");
+    it = ins.first;
+  }
+  it->second.insert(ValStackSlotPair(Val, SS));
+}
+
+void MachineFunction::addSMOpStackSlotMapping(const CallInst *SM,
+                                              unsigned Op,
+                                              int SS) {
+  assert(SM && "Invalid stackmap");
+  assert(Op < SM->getNumArgOperands() && "Invalid operand number");
+  addSMOpStackSlotMapping(SM, SM->getArgOperand(Op), SS);
+}
+
+/// Update stack slot references to new indexes after stack slot coloring
+void
+MachineFunction::updateSMStackSlotRefs(SmallDenseMap<int, int, 16> &Changes) {
+  if(Changes.size()) {
+    // Iterate over all stackmaps
+    DEBUG(dbgs() << "Updating stackmap operand stack slot references\n";);
+    InstOpStackSlotMap::iterator i, ie;
+    for(i = SMOp2StackSlot.begin(), ie = SMOp2StackSlot.end(); i != ie; i++) {
+      // Iterate over all operand/stack slot mappings
+      ValStackSlotMap &Map = i->second;
+      ValStackSlotMap::iterator j, je;
+      for(j = Map.begin(), je = Map.end(); j != je; j++) {
+        SmallDenseMap<int, int, 16>::iterator it;
+        if((it = Changes.find(j->second)) != Changes.end()) {
+          DEBUG(
+            j->first->printAsOperand(dbgs());
+            dbgs() << ": from stack slot " << j->second << " to "
+                   << it->second << "\n";
+          );
+          j->second = it->second;
+        }
+      }
+    }
+  }
+}
+
+/// Return the stack slot mapped to a stackmap operand
+int MachineFunction::getSMStackSlot(const CallInst *SM,
+                                    const Value *Val) const {
+  assert(SM && "Invalid stackmap");
+  assert(Val && "Invalid operand");
+
+  InstOpStackSlotMap::const_iterator i = SMOp2StackSlot.find(SM);
+  if(i != SMOp2StackSlot.end())
+  {
+    ValStackSlotMap::const_iterator j = i->second.find(Val);
+    if(j != i->second.end()) return j->second;
+  }
+  return INT_MAX;
+}
+
+int MachineFunction::getSMStackSlot(const CallInst *SM, unsigned Op) const {
+  assert(SM && "Invalid stackmap");
+  assert(Op < SM->getNumArgOperands() && "Invalid operand number");
+  return getSMStackSlot(SM, SM->getArgOperand(Op));
+}
+
+/// Add an IR/physical register mapping for a stackmap operand
+void MachineFunction::addSMOpPhysRegMapping(const CallInst *SM,
+                                            const Value *Val,
+                                            unsigned Reg) {
+  InstOpPhysRegMap::iterator it;
+  std::pair<InstOpPhysRegMap::iterator, bool> ins;
+
+  assert(SM && "Invalid stackmap");
+  assert(Val && "Invalid operand");
+  assert(TargetRegisterInfo::isPhysicalRegister(Reg) && "Invalid register");
+
+  if((it = SMOp2PhysReg.find(SM)) == SMOp2PhysReg.end())
+  {
+    ValPhysRegMap NewMap;
+    ins = SMOp2PhysReg.insert(InstOpPhysRegPair(SM, std::move(NewMap)));
+    assert(ins.second && "Map insertion error");
+    it = ins.first;
+  }
+  it->second.insert(ValPhysRegPair(Val, Reg));
+}
+
+void MachineFunction::addSMOpPhysRegMapping(const CallInst *SM,
+                                            unsigned Op,
+                                            unsigned Reg) {
+  assert(SM && "Invalid stackmap");
+  assert(Op < SM->getNumArgOperands() && "Invalid operand number");
+  addSMOpPhysRegMapping(SM, SM->getArgOperand(Op), Reg);
+}
+
+/// Return the physical register mapped to a stackmap operand
+unsigned MachineFunction::getSMPhysReg(const CallInst *SM,
+                                       const Value *Val) const {
+  assert(SM && "Invalid stackmap");
+  assert(Val && "Invalid operand");
+
+  InstOpPhysRegMap::const_iterator i = SMOp2PhysReg.find(SM);
+  if(i != SMOp2PhysReg.end())
+  {
+    ValPhysRegMap::const_iterator j = i->second.find(Val);
+    if(j != i->second.end()) return j->second;
+  }
+  return UINT_MAX;
+}
+
+unsigned MachineFunction::getSMPhysReg(const CallInst *SM,
+                                       unsigned Op) const {
+  assert(SM && "Invalid stackmap");
+  assert(Op < SM->getNumArgOperands() && "Invalid operand number");
+  return getSMPhysReg(SM, SM->getArgOperand(Op));
+}
+
 //===----------------------------------------------------------------------===//
 //  MachineFrameInfo implementation
 //===----------------------------------------------------------------------===//
Index: lib/CodeGen/RegAllocBase.cpp
===================================================================
--- lib/CodeGen/RegAllocBase.cpp	(revision 277823)
+++ lib/CodeGen/RegAllocBase.cpp	(working copy)
@@ -14,12 +14,15 @@
 
 #include "RegAllocBase.h"
 #include "Spiller.h"
+#include "llvm/IR/IntrinsicInst.h"
 #include "llvm/ADT/Statistic.h"
 #include "llvm/CodeGen/LiveIntervalAnalysis.h"
 #include "llvm/CodeGen/LiveRangeEdit.h"
 #include "llvm/CodeGen/LiveRegMatrix.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
 #include "llvm/CodeGen/MachineInstr.h"
 #include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/CodeGen/StackMaps.h"
 #include "llvm/CodeGen/VirtRegMap.h"
 #include "llvm/Target/TargetRegisterInfo.h"
 #ifndef NDEBUG
@@ -153,3 +156,280 @@
     }
   }
 }
+
+/// Analyze a machine instruction to see if a value is getting restored from a
+/// spill location.
+void RegAllocBase::getSpillLocation(const MachineInstr *MI,
+                                    SpillLoc &Loc) const {
+  assert(MI && "Invalid machine instruction");
+
+  Loc.type = SpillLoc::NONE;
+  Loc.copy = SpillLoc::VregCopy(0, 0);
+
+  if(MI->isCopy()) { // Check for copies from callee-saved regs
+    unsigned Vreg = 0;
+    unsigned DefVreg = 0;
+    for(unsigned i = 0, e = MI->getNumOperands(); i != e; i++) {
+      const MachineOperand &MO = MI->getOperand(i);
+      if(MO.isReg()) {
+        if(MO.isDef()) DefVreg = MO.getReg();
+        else Vreg = MO.getReg();
+      }
+    }
+
+    if(TargetRegisterInfo::isVirtualRegister(Vreg) &&
+       TargetRegisterInfo::isVirtualRegister(DefVreg)) {
+      Loc.type = SpillLoc::VREG;
+      Loc.copy = SpillLoc::VregCopy(DefVreg, Vreg);
+    }
+  } else if(MI->mayLoad()) { // Check for loads from the stack
+    // TODO emulate Stackmap::IndirectMemRefOp to read spilled location?
+    unsigned DefVreg = 0;
+    int SS = VirtRegMap::NO_STACK_SLOT;
+    for(unsigned i = 0, e = MI->getNumOperands(); i != e; i++) {
+      const MachineOperand &MO = MI->getOperand(i);
+      if(MO.isFI()) SS = MO.getIndex();
+      else if(MO.isReg() && MO.isDef()) DefVreg = MO.getReg();
+    }
+
+    if(TargetRegisterInfo::isVirtualRegister(DefVreg) &&
+       SS != VirtRegMap::NO_STACK_SLOT) {
+      Loc.type = SpillLoc::STACK_SLOT;
+      Loc.load = SpillLoc::StackSlotLoad(DefVreg, SS);
+    }
+  }
+}
+
+/// Return whether or not the specified machine instruction is defined within
+/// the specified range of machine instructions, inclusive
+const MachineInstr *RegAllocBase::definedInRange(const MachineInstr *Start,
+                                                 const MachineInstr *End,
+                                                 unsigned Vreg) const {
+  assert(Start && End && "Invalid machine instruction");
+  assert(TargetRegisterInfo::isVirtualRegister(Vreg) && "Invalid register");
+  assert(Start->getParent() == End->getParent() &&
+         "Range must be contained within the same basic block");
+  const MachineRegisterInfo &MRI = Start->getParent()->getParent()->getRegInfo();
+
+  // The vreg may have multiple definitions, search over all of them
+  for(MachineRegisterInfo::def_instr_iterator DI = MRI.def_instr_begin(Vreg),
+      DIE = MRI.def_instr_end();
+      DI != DIE; DI++) {
+    const MachineInstr *MI = &*DI;
+
+    // Shortcut -- are we the starting or ending instruction of the range?
+    if(MI == Start || MI == End) return MI;
+
+    // Search the range of machine instructions
+    for(const MachineInstr *Cur = Start->getNextNode();
+        Cur != End && Cur != nullptr;
+        Cur = Cur->getNextNode())
+      if(Cur == MI)
+        return MI;
+  }
+
+  // None of the definitions were within the range
+  return nullptr;
+}
+
+void RegAllocBase::findSpilledStackmapOperands()
+{
+  MachineFunction &MF = VRM->getMachineFunction();
+  if(!MF.getFrameInfo()->hasStackMap()) return;
+
+  DEBUG(
+    dbgs() << "\n********** Searching for spilled stackmap operands in "
+           << MF.getName() << " **********\n";
+  );
+
+  // Gather stackmap machine instructions, the IR instructions which generated
+  // the stackmaps, and their associated call machine instructions
+  typedef std::tuple<const CallInst *,
+                     const MachineInstr *,
+                     const MachineInstr *> SMInstBundle;
+  SmallVector<SMInstBundle, 32> SM;
+  static const std::string SMName("llvm.experimental.stackmap");
+  for(auto MBB = MF.begin(), MBBE = MF.end(); MBB != MBBE; MBB++) {
+    for(auto MI = MBB->instr_begin(), MIE = MBB->instr_end();
+        MI != MIE;
+        MI++) {
+      if(MI->getOpcode() == TargetOpcode::STACKMAP) {
+        // Find the stackmap IR instruction
+        assert(MI->getOperand(0).isImm() && "Invalid stackmap ID");
+        int64_t ID = MI->getOperand(0).getImm();
+        const BasicBlock *BB = MI->getParent()->getBasicBlock();
+        const CallInst *SMIR = nullptr;
+        for(auto I = BB->begin(), IE = BB->end(); I != IE; I++)
+        {
+          const IntrinsicInst *II;
+          if((II = dyn_cast<IntrinsicInst>(&*I)) &&
+             II->getCalledFunction()->getName() == SMName &&
+             cast<ConstantInt>(II->getArgOperand(0))->getSExtValue() == ID) {
+            SMIR = cast<CallInst>(II);
+            break;
+          }
+        }
+        assert(SMIR && "Could not find stackmap IR instruction");
+
+        // Find the call instruction
+        const MachineInstr *MCI = MI->getPrevNode();
+        while(MCI != nullptr) {
+          if(MCI->isCall()) {
+            if(MCI->getOpcode() == TargetOpcode::STACKMAP)
+              MCI = nullptr;
+            break;
+          }
+          MCI = MCI->getPrevNode();
+        }
+
+        if(!MCI) {
+          DEBUG(
+            dbgs() << "WARNING: stackmap " << ID << " ";
+            SMIR->printAsOperand(dbgs());
+            dbgs() << ": could not find associated call instruction "
+                      "(has it been lowered to a native instruction?)\n";
+          );
+          continue;
+        }
+
+        SM.push_back(SMInstBundle(SMIR, &*MI, MCI));
+      }
+    }
+  }
+
+  // Iterate over all stackmaps to find virtual register operands which have
+  // been spilled to the stack or to other registers
+  typedef std::pair<unsigned, SmallVector<const Value *, 8> > RegValsPair;
+  DenseMap<unsigned, SmallVector<const Value *, 8> > vregs;
+  DenseMap<unsigned, SmallVector<const Value *, 8> >::iterator vregIt;
+  for(auto S = SM.begin(), SE = SM.end(); S != SE; S++) {
+    const CallInst *SMIR = std::get<0>(*S);
+    const MachineInstr *SMMI = std::get<1>(*S);
+    const MachineInstr *CMI = std::get<2>(*S);
+
+    DEBUG(
+      dbgs() << "\nStackmap " << SMMI->getOperand(0).getImm() << ":\n";
+      SMMI->dump();
+      dbgs() << "\n";
+    );
+
+    // Find all virtual register operands in the machine instruction
+    MachineInstr::const_mop_iterator MOit;
+    CallInst::const_op_iterator IRit;
+    for(MOit = std::next(SMMI->operands_begin(), 2),
+        IRit = std::next(SMIR->op_begin(), 2);
+        MOit != SMMI->operands_end() && IRit != SMIR->op_end();
+        MOit++, IRit++) {
+      // Emulate StackMaps::parseOperand to correlate IR and machine operands
+      if(MOit->isImm()) {
+        switch(MOit->getImm()) {
+        case StackMaps::DirectMemRefOp: MOit++; MOit++; break;
+        case StackMaps::IndirectMemRefOp: MOit++; MOit++; MOit++; break;
+        case StackMaps::ConstantOp: MOit++; break;
+        default: llvm_unreachable("Unrecognized operand type.");
+        }
+      } else if(MOit->isReg()) {
+        const Value *IRVal = IRit->get();
+        unsigned Reg = MOit->getReg();
+
+        assert(IRVal && "Invalid stackmap IR operand");
+        assert(TargetRegisterInfo::isVirtualRegister(Reg) &&
+               "Should not have been converted to physical registers yet");
+
+        DEBUG(
+          IRVal->printAsOperand(dbgs());
+          dbgs() << ": in vreg"
+                 << TargetRegisterInfo::virtReg2Index(Reg) << "\n";
+        );
+
+        if((vregIt = vregs.find(Reg)) == vregs.end()) {
+          SmallVector<const Value *, 8> vals;
+          vregIt = vregs.insert(RegValsPair(Reg, std::move(vals))).first;
+        }
+        vregIt->second.push_back(IRVal);
+      }
+    }
+    assert(IRit == SMIR->op_end() && "Did not search all stackmap operands");
+
+    // Walk from the call to the stackmap, watching for stackmap operand spill
+    // locations
+    const MachineInstr *Cur;
+    for(Cur = CMI->getNextNode(); Cur != SMMI; Cur = Cur->getNextNode()) {
+      // We may be restoring from a chain of copies, so traverse the chain to
+      // find the original spill location.  There are 2 halting conditions for
+      // the while-loop below:
+      //
+      //  1. Restoring the vreg from a spill slot
+      //  2. Restoring the vreg from a callee-saved register allocated to a
+      //     vreg whose definition is NOT between the call and the stackmap
+      //
+      // The second condition is qualified by the location of the definition of
+      // the callee-saved vreg because the backend can generate really stupid
+      // code, e.g., on x86:
+      //
+      //    callq ...
+      //    mov -0x10(%rbp), %rbx
+      //    mov %rbx, %rcx
+      //    <stackmap machine instruction>
+      //
+      // TODO it's not possible to restore from a stack slot, then spill again
+      // before reaching the stackmap, right? This would invalidate #1 above.
+      SpillLoc Loc, DefChain;
+      getSpillLocation(Cur, Loc);
+      DefChain = Loc;
+      while(DefChain.type == SpillLoc::VREG) {
+        const MachineInstr *Def = definedInRange(CMI,
+                                                 SMMI,
+                                                 DefChain.copy.second);
+
+        // Are we in a callee-saved register defined outside of the range of
+        // instructions between the call and the stackmap?
+        if(!MF.isCallerSaved(VRM->getPhys(DefChain.copy.second)) && !Def)
+            break;
+
+        assert(Def && "Invalid vreg definition");
+        getSpillLocation(Def, DefChain);
+      }
+
+      unsigned PhysReg;
+      switch(DefChain.type) {
+      case SpillLoc::VREG:
+        if((vregIt = vregs.find(Loc.copy.first)) != vregs.end()) {
+          PhysReg = VRM->getPhys(DefChain.copy.second);
+          assert(PhysReg != VirtRegMap::NO_PHYS_REG && "Invalid register");
+          assert(!MF.isCallerSaved(PhysReg) && "Invalid register");
+          for(size_t sz = 0; sz < vregIt->second.size(); sz++) {
+            DEBUG(
+              vregIt->second[sz]->printAsOperand(dbgs());
+              dbgs() << ": spilled to callee-saved register "
+                     << PrintReg(PhysReg, &VRM->getTargetRegInfo()) << "\n";
+            );
+            MF.addSMOpPhysRegMapping(SMIR, vregIt->second[sz], PhysReg);
+          }
+        }
+        break;
+      case SpillLoc::STACK_SLOT:
+        if((vregIt = vregs.find(Loc.load.first)) != vregs.end()) {
+          int SS = DefChain.load.second;
+          assert(SS != VirtRegMap::NO_STACK_SLOT && "Invalid stack slot");
+          for(size_t sz = 0; sz < vregIt->second.size(); sz++) {
+            DEBUG(
+              vregIt->second[sz]->printAsOperand(dbgs());
+              dbgs() << ": spilled to stack slot " << SS << "\n";
+            );
+            MF.addSMOpStackSlotMapping(SMIR, vregIt->second[sz], SS);
+          }
+        }
+        break;
+      case SpillLoc::NONE:
+      default:
+        DEBUG(
+          dbgs() << "WARNING: ignoring machine instruction:\n";
+          Cur->dump();
+        );
+        break;
+      }
+    }
+    vregs.clear();
+  }
+}
Index: lib/CodeGen/RegAllocBase.h
===================================================================
--- lib/CodeGen/RegAllocBase.h	(revision 277823)
+++ lib/CodeGen/RegAllocBase.h	(working copy)
@@ -99,6 +99,8 @@
   /// Method called when the allocator is about to remove a LiveInterval.
   virtual void aboutToRemoveInterval(LiveInterval &LI) {}
 
+  /// Find stackmap operands that have been spilled
+  void findSpilledStackmapOperands();
 public:
   /// VerifyEnabled - True when -verify-regalloc is given.
   static bool VerifyEnabled;
@@ -105,6 +107,49 @@
 
 private:
   void seedLiveRegs();
+
+  /// A value's spill location
+  class SpillLoc {
+  public:
+    enum type {
+      NONE,
+      VREG,
+      STACK_SLOT
+    };
+
+    typedef std::pair<unsigned, unsigned> VregCopy;
+    typedef std::pair<unsigned, int> StackSlotLoad;
+
+    SpillLoc() : type(NONE), copy(VregCopy(0, 0)) {}
+
+    SpillLoc& operator=(const SpillLoc &RHS) {
+      if(this != &RHS) {
+        type = RHS.type;
+        switch(type) {
+        case VREG: copy = RHS.copy; break;
+        case STACK_SLOT: load = RHS.load; break;
+        default: copy = VregCopy(0, 0); break;
+        }
+      }
+      return *this;
+    }
+
+    enum type type;
+    union {
+      VregCopy copy;
+      StackSlotLoad load;
+    };
+  };
+
+  /// Analyze a machine instruction to see if a value is getting restored
+  /// from a spill location.
+  void getSpillLocation(const MachineInstr *MI, SpillLoc &Loc) const;
+
+  /// Return the machine instruction that defines the specified Vreg within
+  /// range, or nullptr if it is not defined in that range
+  const MachineInstr *definedInRange(const MachineInstr *Start,
+                                     const MachineInstr *End,
+                                     unsigned Vreg) const;
 };
 
 } // end namespace llvm
Index: lib/CodeGen/RegAllocBasic.cpp
===================================================================
--- lib/CodeGen/RegAllocBasic.cpp	(revision 277823)
+++ lib/CodeGen/RegAllocBasic.cpp	(working copy)
@@ -283,6 +283,7 @@
   SpillerInstance.reset(createInlineSpiller(*this, *MF, *VRM));
 
   allocatePhysRegs();
+  findSpilledStackmapOperands();
 
   // Diagnostic output before rewriting
   DEBUG(dbgs() << "Post alloc VirtRegMap:\n" << *VRM << "\n");
Index: lib/CodeGen/RegAllocFast.cpp
===================================================================
--- lib/CodeGen/RegAllocFast.cpp	(revision 277823)
+++ lib/CodeGen/RegAllocFast.cpp	(working copy)
@@ -1078,6 +1078,10 @@
 /// runOnMachineFunction - Register allocate the whole function
 ///
 bool RAFast::runOnMachineFunction(MachineFunction &Fn) {
+  // TODO stackmap metadata for stack transformation is not yet supported with
+  // the fast register allocator
+  assert(false && "fast register allocator not supported for stack transformation");
+
   DEBUG(dbgs() << "********** FAST REGISTER ALLOCATION **********\n"
                << "********** Function: " << Fn.getName() << '\n');
   MF = &Fn;
Index: lib/CodeGen/RegAllocGreedy.cpp
===================================================================
--- lib/CodeGen/RegAllocGreedy.cpp	(revision 277823)
+++ lib/CodeGen/RegAllocGreedy.cpp	(working copy)
@@ -2570,6 +2570,7 @@
 
   allocatePhysRegs();
   tryHintsRecoloring();
+  findSpilledStackmapOperands();
   releaseMemory();
   return true;
 }
Index: lib/CodeGen/RegAllocPBQP.cpp
===================================================================
--- lib/CodeGen/RegAllocPBQP.cpp	(revision 277823)
+++ lib/CodeGen/RegAllocPBQP.cpp	(working copy)
@@ -720,6 +720,10 @@
 }
 
 bool RegAllocPBQP::runOnMachineFunction(MachineFunction &MF) {
+  // TODO stackmap metadata for stack transformation is not yet supported with
+  // the PBQP register allocator
+  assert(false && "PBQP register allocator not supported for stack transformation");
+
   LiveIntervals &LIS = getAnalysis<LiveIntervals>();
   MachineBlockFrequencyInfo &MBFI =
     getAnalysis<MachineBlockFrequencyInfo>();
Index: lib/CodeGen/StackMaps.cpp
===================================================================
--- lib/CodeGen/StackMaps.cpp	(revision 277823)
+++ lib/CodeGen/StackMaps.cpp	(working copy)
@@ -13,6 +13,7 @@
 #include "llvm/CodeGen/MachineFunction.h"
 #include "llvm/CodeGen/MachineInstr.h"
 #include "llvm/IR/DataLayout.h"
+#include "llvm/IR/IntrinsicInst.h"
 #include "llvm/MC/MCContext.h"
 #include "llvm/MC/MCExpr.h"
 #include "llvm/MC/MCObjectFileInfo.h"
@@ -84,32 +85,63 @@
   return (unsigned)RegNum;
 }
 
+void StackMaps::getPointerInfo(const Value *Op,
+                               const DataLayout &DL,
+                               bool &isPtr, bool &isAlloca,
+                               unsigned &PtrDataSize) const {
+  isPtr = false;
+  isAlloca = false;
+  PtrDataSize = 0;
+
+  assert(Op != nullptr && "Invalid stackmap operand");
+  Type *Ty = Op->getType();
+  if(Ty->isPointerTy())
+  {
+    PointerType *PTy = cast<PointerType>(Ty);
+    if(PTy->getElementType()->isSized())
+    {
+      isPtr = true;
+      PtrDataSize = DL.getTypeAllocSize(PTy->getElementType());
+      if(isa<AllocaInst>(Op)) isAlloca = true;
+    }
+  }
+}
+
 MachineInstr::const_mop_iterator
 StackMaps::parseOperand(MachineInstr::const_mop_iterator MOI,
                         MachineInstr::const_mop_iterator MOE, LocationVec &Locs,
-                        LiveOutVec &LiveOuts) const {
+                        LiveOutVec &LiveOuts, User::const_op_iterator &Op) const {
+  bool isPtr, isAlloca;
+  unsigned PtrDataSize;
+  auto &DL = AP.MF->getDataLayout();
   const TargetRegisterInfo *TRI = AP.MF->getSubtarget().getRegisterInfo();
+  const Value *OpVal = Op->get();
+
   if (MOI->isImm()) {
+    getPointerInfo(OpVal, DL, isPtr, isAlloca, PtrDataSize);
     switch (MOI->getImm()) {
     default:
       llvm_unreachable("Unrecognized operand type.");
     case StackMaps::DirectMemRefOp: {
-      unsigned Size = AP.TM.getDataLayout()->getPointerSizeInBits();
+      unsigned Size = DL.getPointerSizeInBits();
       assert((Size % 8) == 0 && "Need pointer size in bytes.");
       Size /= 8;
       unsigned Reg = (++MOI)->getReg();
       int64_t Imm = (++MOI)->getImm();
       Locs.emplace_back(StackMaps::Location::Direct, Size,
-                        getDwarfRegNum(Reg, TRI), Imm);
+                        getDwarfRegNum(Reg, TRI), Imm, isPtr, isAlloca,
+                        PtrDataSize);
       break;
     }
     case StackMaps::IndirectMemRefOp: {
       int64_t Size = (++MOI)->getImm();
+      int64_t AllocSize = DL.getTypeAllocSize(OpVal->getType());
       assert(Size > 0 && "Need a valid size for indirect memory locations.");
       unsigned Reg = (++MOI)->getReg();
       int64_t Imm = (++MOI)->getImm();
-      Locs.emplace_back(StackMaps::Location::Indirect, Size,
-                        getDwarfRegNum(Reg, TRI), Imm);
+      Locs.emplace_back(StackMaps::Location::Indirect, AllocSize,
+                        getDwarfRegNum(Reg, TRI), Imm, isPtr, isAlloca,
+                        PtrDataSize);
       break;
     }
     case StackMaps::ConstantOp: {
@@ -116,10 +148,12 @@
       ++MOI;
       assert(MOI->isImm() && "Expected constant operand.");
       int64_t Imm = MOI->getImm();
-      Locs.emplace_back(Location::Constant, sizeof(int64_t), 0, Imm);
+      Locs.emplace_back(Location::Constant, sizeof(int64_t), 0, Imm,
+                        isPtr, isAlloca, PtrDataSize);
       break;
     }
     }
+    ++Op;
     return ++MOI;
   }
 
@@ -134,9 +168,64 @@
 
     assert(TargetRegisterInfo::isPhysicalRegister(MOI->getReg()) &&
            "Virtreg operands should have been rewritten before now.");
-    const TargetRegisterClass *RC = TRI->getMinimalPhysRegClass(MOI->getReg());
     assert(!MOI->getSubReg() && "Physical subreg still around.");
 
+    int64_t ID = MOI->getParent()->getOperand(0).getImm();
+    size_t valSize = DL.getTypeAllocSize(OpVal->getType());
+    getPointerInfo(OpVal, DL, isPtr, isAlloca, PtrDataSize);
+    const CallInst *SMIR = cast<CallInst>(Op->getUser());
+
+    // Check if it's been spilled to a stack slot
+    int SS = AP.MF->getSMStackSlot(SMIR, OpVal);
+    const MachineFrameInfo *MFI = AP.MF->getFrameInfo();
+    if(MFI->getObjectIndexBegin() <= SS && SS < MFI->getObjectIndexEnd() &&
+       !MFI->isDeadObjectIndex(SS)) {
+      DEBUG(
+        dbgs() << "Stackmap " << ID << ": ";
+        OpVal->printAsOperand(dbgs());
+        dbgs() << ": in stack slot " << SS << "\n";
+      );
+      int64_t Offset = MFI->getObjectOffset(SS) + 16; // RA + old FBP
+
+      Locs.emplace_back(StackMaps::Location::Indirect, valSize,
+                        getDwarfRegNum(TRI->getFrameRegister(*AP.MF), TRI),
+                        Offset, isPtr, isAlloca, PtrDataSize);
+      ++Op;
+      return ++MOI;
+    }
+
+    // Check if it's been spilled to another register
+    unsigned PhysReg = AP.MF->getSMPhysReg(SMIR, OpVal);
+    if(TargetRegisterInfo::isPhysicalRegister(PhysReg)) {
+      unsigned Offset = 0;
+      unsigned DwarfRegNum = getDwarfRegNum(PhysReg, TRI);
+      unsigned LLVMRegNum = TRI->getLLVMRegNum(DwarfRegNum, false);
+      unsigned SubRegIdx = TRI->getSubRegIndex(LLVMRegNum, MOI->getReg());
+      if (SubRegIdx)
+        Offset = TRI->getSubRegIdxOffset(SubRegIdx);
+
+      DEBUG(
+        dbgs() << "Stackmap " << ID << ": ";
+        OpVal->printAsOperand(dbgs());
+        dbgs() << ": in register " << DwarfRegNum << "\n";
+      );
+
+      Locs.emplace_back(Location::Register, valSize, DwarfRegNum, Offset,
+                        isPtr, isAlloca, PtrDataSize);
+      ++Op;
+      return ++MOI;
+    }
+
+    // Can't find the spilled location, so follow the normal register path
+    if(AP.MF->isCallerSaved(MOI->getReg())) {
+      DEBUG(
+        dbgs() << "WARNING: ";
+        OpVal->printAsOperand(dbgs());
+        dbgs() << ": no spill location for caller-saved register "
+               << getDwarfRegNum(MOI->getReg(), TRI) << "\n";
+      );
+    }
+
     unsigned Offset = 0;
     unsigned DwarfRegNum = getDwarfRegNum(MOI->getReg(), TRI);
     unsigned LLVMRegNum = TRI->getLLVMRegNum(DwarfRegNum, false);
@@ -144,7 +233,9 @@
     if (SubRegIdx)
       Offset = TRI->getSubRegIdxOffset(SubRegIdx);
 
-    Locs.emplace_back(Location::Register, RC->getSize(), DwarfRegNum, Offset);
+    Locs.emplace_back(Location::Register, valSize, DwarfRegNum, Offset,
+                      isPtr, isAlloca, PtrDataSize);
+    ++Op;
     return ++MOI;
   }
 
@@ -285,6 +376,7 @@
   MCContext &OutContext = AP.OutStreamer->getContext();
   MCSymbol *MILabel = OutContext.createTempSymbol();
   AP.OutStreamer->EmitLabel(MILabel);
+  User::const_op_iterator Op = nullptr;
 
   LocationVec Locations;
   LiveOutVec LiveOuts;
@@ -292,13 +384,33 @@
   if (recordResult) {
     assert(PatchPointOpers(&MI).hasDef() && "Stackmap has no return value.");
     parseOperand(MI.operands_begin(), std::next(MI.operands_begin()), Locations,
-                 LiveOuts);
+                 LiveOuts, Op);
   }
 
+  // Find the IR stackmap instruction which corresponds to MI so we can emit
+  // type information along with the value's location
+  const BasicBlock *BB = MI.getParent()->getBasicBlock();
+  const IntrinsicInst *IRSM = nullptr;
+  const std::string SMName("llvm.experimental.stackmap");
+  for(auto BBI = BB->begin(), BBE = BB->end(); BBI != BBE; BBI++)
+  {
+    const IntrinsicInst *II;
+    if((II = dyn_cast<IntrinsicInst>(&*BBI)) &&
+       II->getCalledFunction()->getName() == SMName &&
+       cast<ConstantInt>(II->getArgOperand(0))->getZExtValue() == ID)
+    {
+      IRSM = cast<IntrinsicInst>(&*BBI);
+      break;
+    }
+  }
+  assert(IRSM && "Could not find associated stackmap instruction");
+
   // Parse operands.
+  Op = std::next(IRSM->op_begin(), 2);
   while (MOI != MOE) {
-    MOI = parseOperand(MOI, MOE, Locations, LiveOuts);
+    MOI = parseOperand(MOI, MOE, Locations, LiveOuts, Op);
   }
+  assert(Op == IRSM->op_end() && "did not lower all stackmap operands");
 
   // Move large constants into the constant pool.
   for (auto &Loc : Locations) {
@@ -327,8 +439,8 @@
       MCSymbolRefExpr::create(MILabel, OutContext),
       MCSymbolRefExpr::create(AP.CurrentFnSymForSize, OutContext), OutContext);
 
-  CSInfos.emplace_back(CSOffsetExpr, ID, std::move(Locations),
-                       std::move(LiveOuts));
+  CSInfos.emplace_back(AP.CurrentFnSym, CSOffsetExpr, ID,
+                       std::move(Locations), std::move(LiveOuts));
 
   // Record the stack size of the current function.
   const MachineFrameInfo *MFI = AP.MF->getFrameInfo();
@@ -417,7 +529,7 @@
   DEBUG(dbgs() << WSMP << "functions:\n");
   for (auto const &FR : FnStackSize) {
     DEBUG(dbgs() << WSMP << "function addr: " << FR.first
-                 << " frame size: " << FR.second);
+                 << " frame size: " << FR.second << "\n");
     OS.EmitSymbolValue(FR.first, 8);
     OS.EmitIntValue(FR.second, 8);
   }
@@ -439,6 +551,8 @@
 ///
 /// StkMapRecord[NumRecords] {
 ///   uint64 : PatchPoint ID
+///   uint32 : Index of Function Stack Size Record
+///   uint32 : Padding
 ///   uint32 : Instruction Offset
 ///   uint16 : Reserved (record flags)
 ///   uint16 : NumLocations
@@ -447,6 +561,10 @@
 ///     uint8  : Size in Bytes
 ///     uint16 : Dwarf RegNum
 ///     int32  : Offset
+///     uint8  : Is it a pointer?
+///     uint8  : Is it an alloca?
+///     uint16 : Padding
+///     uint32 : Size of pointed-to data
 ///   }
 ///   uint16 : Padding
 ///   uint16 : NumLiveOuts
@@ -487,6 +605,8 @@
     }
 
     OS.EmitIntValue(CSI.ID, 8);
+    OS.EmitIntValue(FnStackSize.find(CSI.Func) - FnStackSize.begin(), 4);
+    OS.EmitIntValue(0, 4);
     OS.EmitValue(CSI.CSOffsetExpr, 4);
 
     // Reserved for flags.
@@ -498,6 +618,10 @@
       OS.EmitIntValue(Loc.Size, 1);
       OS.EmitIntValue(Loc.Reg, 2);
       OS.EmitIntValue(Loc.Offset, 4);
+      OS.EmitIntValue(Loc.Ptr, 1);
+      OS.EmitIntValue(Loc.Alloca, 1);
+      OS.EmitIntValue(0, 2);
+      OS.EmitIntValue(Loc.PtrDataSize, 4);
     }
 
     // Num live-out registers and padding to align to 4 byte.
Index: lib/CodeGen/StackSlotColoring.cpp
===================================================================
--- lib/CodeGen/StackSlotColoring.cpp	(revision 277823)
+++ lib/CodeGen/StackSlotColoring.cpp	(working copy)
@@ -278,6 +278,7 @@
   SmallVector<int, 16> SlotMapping(NumObjs, -1);
   SmallVector<float, 16> SlotWeights(NumObjs, 0.0);
   SmallVector<SmallVector<int, 4>, 16> RevMap(NumObjs);
+  SmallDenseMap<int, int, 16> SlotChanges;
   BitVector UsedColors(NumObjs);
 
   DEBUG(dbgs() << "Color spill slot intervals:\n");
@@ -292,7 +293,9 @@
     SlotWeights[NewSS] += li->weight;
     UsedColors.set(NewSS);
     Changed |= (SS != NewSS);
+    if(SS != NewSS) SlotChanges[SS] = NewSS;
   }
+  MF.updateSMStackSlotRefs(SlotChanges);
 
   DEBUG(dbgs() << "\nSpill slots after coloring:\n");
   for (unsigned i = 0, e = SSIntervals.size(); i != e; ++i) {
Index: lib/Target/AArch64/AArch64AsmPrinter.cpp
===================================================================
--- lib/Target/AArch64/AArch64AsmPrinter.cpp	(revision 277823)
+++ lib/Target/AArch64/AArch64AsmPrinter.cpp	(working copy)
@@ -129,8 +129,8 @@
     // linker can safely perform dead code stripping.  Since LLVM never
     // generates code that does this, it is always safe to set.
     OutStreamer->EmitAssemblerFlag(MCAF_SubsectionsViaSymbols);
-    SM.serializeToStackMapSection();
   }
+  SM.serializeToStackMapSection();
 }
 
 MachineLocation
Index: lib/Target/X86/X86AsmPrinter.cpp
===================================================================
--- lib/Target/X86/X86AsmPrinter.cpp	(revision 277823)
+++ lib/Target/X86/X86AsmPrinter.cpp	(working copy)
@@ -49,6 +49,8 @@
 bool X86AsmPrinter::runOnMachineFunction(MachineFunction &MF) {
   Subtarget = &MF.getSubtarget<X86Subtarget>();
 
+  bool modified = TagCallSites(MF);
+
   SMShadowTracker.startFunction(MF);
 
   SetupMachineFunction(MF);
@@ -66,8 +68,8 @@
   // Emit the rest of the function body.
   EmitFunctionBody();
 
-  // We didn't modify anything.
-  return false;
+  // We may have modified where stack map intrinsics are located.
+  return modified;
 }
 
 /// printSymbolOperand - Print a raw symbol reference operand.  This handles
