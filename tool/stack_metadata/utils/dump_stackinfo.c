/**
 * Utility for dumping information produced by post-compilation augmentation
 * tool.
 *
 * Author: Rob Lyerly <rlyerly@vt.edu>
 * Date: 1/8/2016
 */

#include <unistd.h>

#include "definitions.h"
#include "bin.h"
#include "stackmap.h"
#include "util.h"
#include "het_bin.h"

///////////////////////////////////////////////////////////////////////////////
// Configuration
///////////////////////////////////////////////////////////////////////////////

static const char *args = "hb:s:";
static const char *help =
"dump-stackinfo - dump information generated by gen-stackinfo\n\n\
\
Usage: ./dump-stackinfo [ OPTIONS ]\n\
Options:\n\
\t-h      : print help & exit\n\
\t-b file : name of post-processed executable\n\
\t-s name : name of section added to objects (default is '.stack_transform')";

static const char *thebin_fn = NULL;
static const char *st_section_name = ".stack_transform";
bool verbose = false;

///////////////////////////////////////////////////////////////////////////////
// Utilities
///////////////////////////////////////////////////////////////////////////////

static void print_help()
{
  printf("%s\n", help);
  exit(0);
}

static void parse_args(int argc, char **argv)
{
  int arg;

  while((arg = getopt(argc, argv, args)) != -1)
  {
    switch(arg)
    {
    case 'h':
      print_help();
      break;
    case 'b':
      thebin_fn = optarg;
      break;
    case 's':
      st_section_name = optarg;
      break;
    default:
      fprintf(stderr, "Unknown argument '%c'\n", arg);
      break;
    }
  }

  if(!thebin_fn)
    die("please specify a binary (run with -h for more information)",
        INVALID_ARGUMENT);
}

///////////////////////////////////////////////////////////////////////////////
// Printing metadata
///////////////////////////////////////////////////////////////////////////////

bool dump_callsite_section(Elf_Scn *scn)
{
  uint64_t num_sites, i;
  Elf_Data *data = NULL;
  GElf_Shdr shdr;
  call_site *sites;

  if(gelf_getshdr(scn, &shdr) != &shdr) return false;
  if(shdr.sh_size == 0 || shdr.sh_entsize == 0) return false;
  if(!(data = elf_getdata(scn, data))) return false;

  num_sites = shdr.sh_size / shdr.sh_entsize;
  sites = (call_site *)data->d_buf;
  printf("found %lu entries\n", num_sites);
  for(i = 0; i < num_sites; i++)
    printf("%lu: 0x%lx, %u, %u live value(s) (offset=%lu)\n",
      sites[i].id, sites[i].addr, sites[i].fbp_offset,
      sites[i].num_live, sites[i].live_offset);
  printf("\n");

  return true;
}

bool print_loc_record(call_site_value record)
{
  switch(record.type) {
  case SM_REGISTER:
    printf("in register %u", record.regnum);
    break;
  case SM_DIRECT:
    printf("at register %u + %d",
          record.regnum, record.offset_or_constant);
    break;
  case SM_INDIRECT:
    printf("at pointer generated by register %u + %d",
          record.regnum, record.offset_or_constant);
    break;
  case SM_CONSTANT:
    printf("%d", record.offset_or_constant);
    break;
  case SM_CONST_IDX:
    printf("in constant pool at index %d",
          record.offset_or_constant);
    break;
  default:
    return false;
  }

  if(record.is_ptr)
  {
    printf(", points to data of size %u byte(s)", record.pointed_size);
    if(record.is_alloca)
      printf(", is an alloca\n");
    else
      printf("\n");
  }
  else
    printf("\n");

  return true;
}

bool dump_livelocs_section(Elf_Scn *scn)
{
  uint64_t num_locs, i;
  Elf_Data *data = NULL;
  GElf_Shdr shdr;
  call_site_value *locs;

  if(gelf_getshdr(scn, &shdr) != &shdr) return false;
  if(shdr.sh_size == 0 || shdr.sh_entsize == 0) return false;
  if(!(data = elf_getdata(scn, data))) return false;

  num_locs = shdr.sh_size / shdr.sh_entsize;
  locs = (call_site_value *)data->d_buf;
  printf("found %lu entries\n", num_locs);
  for(i = 0; i < num_locs; i++)
  {
    printf("%lu: value is ", i);
    if(!print_loc_record(locs[i])) return false;
  }
  printf("\n");

  return true;
}

ret_t dump_metadata(bin *thebin)
{
  char sec_name[BUF_SIZE];
  Elf_Scn *scn;

  snprintf(sec_name, BUF_SIZE, "%s.%s", st_section_name, SECTION_ID);
  if((scn = get_section_by_name(thebin->e, sec_name)))
  {
    printf("Reading section %s: ", sec_name);
    if(!dump_callsite_section(scn))
    {
      printf("failed.\n");
      return READ_ELF_FAILED;
    }
  }
  else return FIND_SECTION_FAILED;

  snprintf(sec_name, BUF_SIZE, "%s.%s", st_section_name, SECTION_ADDR);
  if((scn = get_section_by_name(thebin->e, sec_name)))
  {
    printf("Reading section %s: ", sec_name);
    if(!dump_callsite_section(scn))
    {
      printf("failed.\n");
      return READ_ELF_FAILED;
    }
  }
  else return FIND_SECTION_FAILED;

  snprintf(sec_name, BUF_SIZE, "%s.%s", st_section_name, SECTION_LIVE);
  if((scn = get_section_by_name(thebin->e, sec_name)))
  {
    printf("Reading section %s: ", sec_name);
    if(!dump_livelocs_section(scn))
    {
      printf("failed.\n");
      return READ_ELF_FAILED;
    }
  }
  else return FIND_SECTION_FAILED;

  return SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
// Driver
///////////////////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
  ret_t ret;
  bin *thebin = NULL;

  parse_args(argc, argv);

  if(elf_version(EV_CURRENT) == EV_NONE)
    die("could not initialize libELF", INVALID_ELF_VERSION);

  if((ret = init_elf_bin(thebin_fn, &thebin)) != SUCCESS)
    die("could not initialize the binary", ret);

  if((ret = dump_metadata(thebin)) != SUCCESS)
    die("could not read metadata from binary", ret);

  free_elf_bin(thebin);

  return 0;
}

