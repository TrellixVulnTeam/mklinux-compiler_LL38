/**
 * Data structures for stack maps generated by LLVM.
 *
 * Note: Register numbers correspond to the architecture-specific DWARF
 * register mapping.
 *
 * Author: Rob Lyerly <rlyerly@vt.edu>
 * Date: 5/25/2016
 */

#ifndef _STACKMAP_H
#define _STACKMAP_H

#include "definitions.h"
#include "bin.h"
#include "call_site.h"

/* Stack map section header. */
typedef struct __attribute__((__packed__)) sm_header {
  uint8_t version;
  uint8_t reserved;
  uint16_t reserved2;
} sm_header;

/* A stack size record for a function. */
typedef struct __attribute__((__packed__)) sm_stack_size_record {
  uint64_t func_addr;
  uint64_t stack_size;
  uint32_t unwind_offset;
  uint32_t num_unwind;
} sm_stack_size_record;

/* A set of location descriptions. */
// Note: sizeof(struct sm_locations) will return invalid value
typedef struct __attribute__((__packed__)) sm_locations {
  uint16_t num;
  call_site_value record[0]; /* variable number of records */
} sm_locations;

/* A live register across the stack map call. */
typedef struct __attribute__((__packed__)) sm_live_out_record {
  uint16_t regnum;
  uint8_t reserved;
  uint8_t size; /* in bytes */
} sm_live_out_record;

/* A set of live-out records. */
// Note: sizeof(struct sm_locations) will return invalid value
typedef struct __attribute__((__packed__)) sm_live_outs {
  uint16_t num;
  sm_live_out_record record[0]; /* variable number of records */
} sm_live_outs;

/* A stack map record. */
typedef struct __attribute__((__packed__)) sm_stack_map_record {
  uint64_t id;
  uint32_t func_idx; /* index into stack_sizes for function information */
  uint32_t padding;
  uint32_t offset; /* offset from beginning of function */
  uint16_t reserved;
  sm_locations *locations;
  sm_live_outs *live_outs;
} sm_stack_map_record;

/* Per-module stack map information. */
typedef struct stack_map {
  struct sm_header header;

  uint32_t num_functions;
  uint32_t num_constants;
  uint32_t num_records;

  sm_stack_size_record *stack_sizes;
  uint64_t *constants;
  sm_stack_map_record *stack_maps;
} stack_map;

/**
 * Read stack map information from a binary.
 * @param b a binary
 * @param sm a pointer that will be initialized to an array of stack map
 *        structs
 * @param num_sm number of stackmap structs parsed
 * @return 0 if successful, an error code otherwise
 */
ret_t init_stackmap(bin *b, stack_map **sm_ptr, size_t *num_sm);

/**
 * Free stack map data.
 * @param sm stack maps
 * @param num_sm number of stack maps
 * @return 0 if successful, an error code otherwise
 */
ret_t free_stackmaps(stack_map *sm, size_t num_sm);

#endif

